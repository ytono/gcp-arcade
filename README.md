## 1. Keycloakの機能と概念

Keycloakは、WebアプリケーションやRESTful Webサービス向けのシングルサインオンソリューションです。 Keycloakの目標は、セキュリティをシンプルにすることで、アプリケーション開発者が組織にデプロイされたアプリケーションやサービスを簡単に保護できるようにすることです。 通常、開発者が自分で記述する必要があるセキュリティ機能は、すぐに使用できるように提供されており、組織の個々の要件に合わせて簡単に調整できます。 Keycloakは、ログイン、登録、管理、アカウント管理のためのカスタマイズ可能なユーザーインターフェースを提供します。 また、Keycloakを統合プラットフォームとして使用して、既存のLDAPおよびActive Directoryサーバーに接続することもできます。 FacebookやGoogleなどのサードパーティのIDプロバイダーに認証を委任することもできます。

### 特徴

Keycloakは、次の機能を提供します。

* ブラウザアプリケーションのシングルサインオンとシングルサインアウト。
* OpenID Connectのサポート。
* OAuth 2.0のサポート。
* SAMLのサポート。
* IDブローカー - 外部OpenID ConnectまたはSAML IDプロバイダーによる認証。
* ソーシャルログイン - Google、GitHub、Facebook、Twitter、その他のソーシャルネットワークでのログインを有効にします。
* ユーザーフェデレーション - LDAPおよびActive Directoryサーバーからユーザーを同期します。
* Kerberosブリッジ - Kerberosサーバーにログインしているユーザーを自動的に認証します。
* ユーザー、ロール、ロールマッピング、クライアント、設定を一元管理するための管理コンソール。
* ユーザーが自分のアカウントを一元管理できるアカウントコンソール。
* テーマのサポート - すべてのユーザー向けページをカスタマイズして、アプリケーションやブランドに統合できます。
* 2要素認証 - Google AuthenticatorまたはFreeOTPを介したTOTP / HOTPのサポート。
* ログインフロー - オプションのユーザーセルフ登録、パスワードの回復、メールの確認、パスワードの更新の要求など。
* セッション管理 - 管理者とユーザー自身がユーザーセッションを表示および管理できます。
* トークンマッパー - ユーザー属性、ロールなどをトークンやステートメントにマッピングする方法を指定します。
* レルム、アプリケーション、ユーザーごとに、not-before失効ポリシーを設定できます。
* CORSのサポート - クライアントアダプターには、CORSの組み込みサポートがあります。
* サービスプロバイダーインターフェース（SPI） - サーバーのさまざまな側面をカスタマイズできるようにするための多数のSPI。 認証フロー、ユーザーフェデレーションプロバイダー、プロトコルマッパーなど。
* OpenID ConnectリライングパーティライブラリまたはSAML 2.0サービスプロバイダーライブラリを持つ、あらゆるプラットフォーム/言語をサポートします。

### 基本的なKeycloakの操作

Keycloakは、ネットワーク上で管理する独立したサーバーです。 アプリケーションは、このサーバーを指し示し、このサーバーによって保護されるように構成されます。 Keycloakは、OpenID ConnectやSAML 2.0などのオープンなプロトコル標準を使用して、アプリケーションを保護します。 ブラウザアプリケーションは、ユーザーのブラウザをアプリケーションからKeycloak認証サーバーにリダイレクトし、そこで資格情報を入力します。 このリダイレクトは、ユーザーがアプリケーションから完全に分離され、アプリケーションがユーザーの資格情報を決して見ることがないため、重要です。 代わりに、アプリケーションには、暗号化によって署名されたIDトークンまたはアサーションが提供されます。 これらのトークンには、ユーザー名、住所、メールアドレス、その他のプロファイルデータなどのID情報を含めることができます。 また、アプリケーションが承認の決定を下せるように、アクセス許可データを含めることもできます。 これらのトークンは、RESTベースのサービスで安全な呼び出しを行うためにも使用できます。

### Keycloak 主要な概念と用語

| 概念 | 説明 |
|---|---|
| **ユーザー** | システムにログインできるエンティティ。 メール、ユーザー名、住所、電話番号、誕生日などの属性を関連付けられます。 グループメンバーシップに割り当てられ、特定のロールを割り当てることができます。 |
| **認証** | ユーザーを特定し、検証するプロセス。 |
| **承認** | ユーザーにアクセス権を付与するプロセス。 |
| **資格情報** | ユーザーのIDを確認するためにKeycloakが使用するデータ。 パスワード、ワンタイムパスワード、デジタル証明書、指紋などが挙げられます。 |
| **ロール** | ユーザーのタイプまたはカテゴリを識別します。 管理者、ユーザー、マネージャー、従業員はすべて、組織内に存在する可能性のある典型的なロールです。 |
| **ユーザーロールマッピング** | ロールとユーザー間のマッピングを定義します。 ユーザーは、ゼロ個以上のロールに関連付けることができます。 |
| **複合ロール** | 他のロールに関連付けることができるロール。 |
| **グループ** | ユーザーのグループを管理します。 属性は、グループに対して定義できます。 また、ロールをグループにマッピングすることもできます。 |
| **レルム** | ユーザー、資格情報、ロール、グループのセットを管理します。 ユーザーはレルムに属し、レルムにログインします。 |
| **クライアント** | Keycloakにユーザーの認証を要求できるエンティティ。 |
| **クライアントアダプター** | Keycloakと通信し、Keycloakによって保護されるように、アプリケーション環境にインストールするプラグイン。 |
| **同意** | 管理者であるユーザーが、クライアントが認証プロセスに参加する前に、クライアントにアクセス許可を与えることをユーザーに求める場合です。 |
| **クライアントスコープ** | 共通の設定をいくつか共有することで、新しいクライアントの作成を容易にするために、クライアントのプロトコルマッパーとロールスコープマッピングを定義します。 |
| **クライアントロール** | クライアントは、自分に固有のロールを定義できます。 |
| **IDトークン** | ユーザーに関するID情報を提供するトークン。 OpenID Connect仕様の一部。 |
| **アクセストークン** | 呼び出されるサービスへのアクセスを許可するHTTPリクエストの一部として提供できるトークン。 |
| **アサーション** | ユーザーに関する情報。 通常、認証されたユーザーに関するIDメタデータを提供するSAML認証応答に含まれるXML BLOBを指します。 |
| **サービスアカウント** | 各クライアントには、アクセストークンを取得するために使用できる組み込みのサービスアカウントがあります。 |
| **ダイレクトグラント** | クライアントがREST呼び出しを介してユーザーに代わってアクセストークンを取得する方法。 |
| **プロトコルマッパー** | クライアントごとに、OIDCトークンまたはSAMLアサーションに格納されるクレームとアサーションを調整できます。 |
| **セッション** | ユーザーがログインすると、ログインセッションを管理するためのセッションが作成されます。 |
| **ユーザーフェデレーションプロバイダー** | Keycloakは、ユーザーを格納および管理できます。 企業では、ユーザーと資格情報を格納するLDAPまたはActive Directoryサービスがすでに用意されていることがよくあります。 |
| **IDプロバイダー** | IDプロバイダー（IDP）は、ユーザーを認証できるサービスです。 KeycloakはIDPです。 |
| **IDプロバイダーフェデレーション** | Keycloakは、1つ以上のIDPに認証を委任するように構成できます。 |
| **IDプロバイダーマッパー** | IDPフェデレーションを実行する場合、受信トークンとアサーションをユーザー属性とセッション属性にマッピングできます。 |
| **必須アクション** | 必須アクションとは、認証プロセス中にユーザーが実行する必要があるアクションです。 |
| **認証フロー** | 認証フローは、ユーザーがシステムの特定の側面を操作するときに実行する必要があるワークフローです。 |
| **イベント** | イベントは、管理者が表示して接続できる監査ストリームです。 |
| **テーマ** | Keycloakによって提供されるすべての画面は、テーマによってサポートされています。 |

## 2. Keycloak の最初の管理者の作成

Keycloak をインストールした後、Keycloak を管理するためのフルパーミッションを持つスーパー管理者として機能できる管理者アカウントが必要です。このアカウントを使用すると、Keycloak 管理コンソールにログインして、レルムとユーザーを作成し、Keycloak によって保護されているアプリケーションを登録できます。

### ローカルホストでアカウントを作成する

サーバーに localhost からアクセスできる場合は、次の手順を実行します。

**手順**

1. Web ブラウザで、`http://localhost:8080` URL にアクセスします。
2. 記憶できるユーザー名とパスワードを入力します。
3. ウェルカムページが表示されます。

### リモートでアカウントを作成する

![](Picture)

localhost アドレスからサーバーにアクセスできない場合、またはコマンドラインから Keycloak を起動する場合は、`KEYCLOAK_ADMIN` および `KEYCLOAK_ADMIN_PASSWORD` 環境変数を使用して、初期管理者アカウントを作成します。

**例:**

```
export KEYCLOAK_ADMIN=<ユーザー名>
export KEYCLOAK_ADMIN_PASSWORD=<パスワード>

bin/kc.[sh|bat] start
```

## 3. レルムの構成

管理コンソールの管理者アカウントを取得したら、レルムを構成できます。レルムは、ユーザー、アプリケーション、ロール、グループなどのオブジェクトを管理するスペースです。ユーザーはレルムに属し、レルムにログインします。1 つの Keycloak デプロイメントで、データベースの容量に応じて、必要な数のレルムを定義、保存、および管理できます。

### 管理コンソールの使用

レルムの構成とほとんどの管理タスクは、Keycloak 管理コンソールで実行します。

**前提条件**

* 管理者アカウントが必要です。「最初の管理者の作成」を参照してください。

**手順**

1. 管理コンソールの URL にアクセスします。たとえば、localhost の場合は、次の URL を使用します。 `http://localhost:8080/admin/`
2. ログインページが表示されます。

![](Picture)

3. ウェルカムページまたは環境変数を使用して作成したユーザー名とパスワードを入力します。「初期管理ユーザーの作成」ガイドを参照してください。
管理コンソールが表示されます。

![](Picture)

使用できるメニューとその他のオプションに注意してください。

* 「マスター」というラベルのメニューをクリックして、管理するレルムを選択するか、新しいレルムを作成します。
* 右上のリストをクリックして、アカウントを表示するか、ログアウトします。
* 疑問符（?）アイコンにカーソルを合わせると、そのフィールドを説明するツールチップテキストが表示されます。上の画像では、ツールチップが動作しています。
* 疑問符（?）アイコンをクリックすると、そのフィールドを説明するツールチップテキストが表示されます。上の画像では、ツールチップが動作しています。

**管理コンソールからエクスポートされたファイルは、サーバー間のバックアップやデータ転送には適していません。起動時のエクスポートのみが、サーバー間のバックアップやデータ転送に適しています。**

### マスターレルム

管理コンソールには、次の 2 種類のレルムが存在します。

* **マスターレルム:** このレルムは、Keycloak を最初に起動したときに作成されました。最初のログイン時に作成した管理者アカウントが含まれています。マスターレルムは、システム内のレルムを作成および管理するためだけに使用します。
* **その他のレルム:** これらのレルムは、マスターレルムの管理者によって作成されます。これらのレルムでは、管理者は組織内のユーザーと、ユーザーが必要とするアプリケーションを管理します。アプリケーションはユーザーが所有しています。

![](Picture)

**レルムとアプリケーション**

レルムは互いに分離されており、制御しているユーザーの管理と認証のみを行うことができます。このセキュリティモデルに従うことで、偶発的な変更を防ぎ、ユーザーアカウントに現在のタスクの正常な完了に必要な権限と権限のみへのアクセスを許可するという伝統に従うことができます。

**追加資料**

* マスターレルムを無効にし、作成した新しいレルム内で管理者アカウントを定義する場合は、「専用レルム管理コンソール」を参照してください。各レルムには、ローカルアカウントでログインできる独自の専用管理コンソールがあります。

### レルムの作成

レルムを作成して、ユーザーを作成し、アプリケーションを使用するための権限をユーザーに付与できる管理スペースを提供します。最初のログイン時は、通常、他のレルムを作成する最上位レベルのレルムであるマスターレルムにいます。

必要なレルムを決定する際には、ユーザーとアプリケーションにどのような分離が必要かを検討してください。たとえば、会社の従業員用のレルムと、顧客用の別のレルムを作成できます。従業員は従業員レルムにログインし、社内アプリケーションのみにアクセスできます。顧客は顧客レルムにログインし、顧客向けアプリとのみやり取りできます。

**手順**

1. 「マスターレルム」の横にある「Keycloak」をクリックし、「レルムの作成」をクリックします。

**メニューの追加**

![](Picture)

2. レルムの名前を入力します。
3. 「作成」をクリックします。

**レルムの作成**

現在のレルムは、作成したレルムに設定されます。メニューのレルム名をクリックすると、レルムを切り替えることができます。

### レルムの SSL の構成

各レルムには、レルムとの対話のための SSL/HTTPS 要件を定義する、関連付けられた SSL モードがあります。レルムと対話するブラウザとアプリケーションは、SSL モードで定義された SSL/HTTPS 要件を満たしている必要があります。満たしていない場合は、サーバーと対話できません。

**手順**

1. メニューの「レルム設定」をクリックします。
2. 「全般」タブをクリックします。

**全般タブ**

3. 「SSL を必須にする」を次のいずれかの SSL モードに設定します。
* **外部リクエスト:** ユーザーは、localhost、127.0.0.1、10.x.x.x、192.168.x.x、172.16.x.x などのプライベート IP アドレスに固執している限り、SSL なしで Keycloak と対話できます。プライベート以外の IP アドレスから SSL なしで Keycloak にアクセスしようとすると、エラーが発生します。
* **なし:** Keycloak は SSL を必要としません。この選択肢は、実験中で、このデプロイメントをサポートする予定がない開発時にのみ適用されます。
* **すべてのリクエスト:** Keycloak は、すべての IP アドレスに対して SSL を必要とします。

### レルムのメールの構成

Keycloak は、ユーザーにメールアドレスを確認させるため、パスワードを忘れた場合、または管理者がサーバーイベントに関する通知を受け取る必要がある場合に、ユーザーにメールを送信します。Keycloak がメールを送信できるようにするには、Keycloak に SMTP サーバー設定を提供します。

**手順**

1. メニューの「レルム設定」をクリックします。
2. 「メール」タブをクリックします。

**メールタブ**

3. 必要に応じて、フィールドに入力し、スイッチを切り替えます。

**テンプレート**

* **送信者:** 送信されたメールの送信元 SMTP ヘッダーに使用されるアドレスを示します。
* **送信者表示名:** ユーザーフレンドリーなメールアドレスエイリアスを構成できます（オプション）。設定されていない場合は、プレーンテキストの送信者メールアドレスがメールクライアントに表示されます。
* **返信先:** 送信されたメールの返信先 SMTP ヘッダーに使用されるアドレスを示します（オプション）。設定されていない場合は、プレーンテキストの送信者メールアドレスが使用されます。
* **返信先表示名:** ユーザーフレンドリーなメールアドレスエイリアスを構成できます（オプション）。設定されていない場合は、プレーンテキストの返信先メールアドレスが表示されます。
* **エンベロープ送信者:** 送信されたメールの返信パス SMTP ヘッダーに使用される「バウンスアドレス」を示します（オプション）。

**接続と認証**

* **ホスト:** メール送信に使用される SMTP サーバーのホスト名を示します。
* **ポート:** SMTP サーバーのポートを示します。
* **暗号化:** これらのチェックボックスのいずれかを選択して、ユーザー名とパスワードを回復するためのメール送信をサポートします。特に、SMTP サーバーが外部ネットワーク上にある場合に役立ちます。SSL/TLS のデフォルトポートである 465 に「ポート」を変更する必要がある可能性があります。
* **認証:** SMTP サーバーで認証が必要な場合は、このスイッチを「オン」に設定します。プロンプトが表示されたら、「ユーザー名」と「パスワード」を入力します。「パスワード」フィールドの値は、外部の「ボールト」からの値を参照できます。

### テーマの構成

特定のレルムについて、テーマを使用して Keycloak の UI の外観を変更できます。

**手順**

1. メニューの「レルム設定」をクリックします。
2. 「テーマ」タブをクリックします。

**テーマタブ**

3. 各 UI カテゴリに必要なテーマを選択し、「保存」をクリックします。

* **ログインテーマ:** ユーザー名とパスワードの入力、OTP の入力、新規ユーザー登録など、ログインに関連するその他の同様の画面。
* **アカウントテーマ:** ユーザーが自分のアカウントを管理するために使用するコンソール。
* **管理コンソールテーマ:** Keycloak 管理コンソールのスキン。
* **メールテーマ:** Keycloak がメールを送信する必要がある場合は常に、このテーマで定義されたテンプレートを使用してメールが作成されます。

**追加資料**

* 「サーバー開発者ガイド」では、新しいテーマの作成方法または既存のテーマの変更方法について説明しています。

### 国際化の有効化

すべての UI 画面は Keycloak で国際化されています。デフォルトの言語は英語ですが、サポートするロケールとデフォルトのロケールを選択できます。

**手順**

1. メニューの「レルム設定」をクリックします。
2. 「ローカリゼーション」タブをクリックします。
3. 「国際化」を有効にします。
4. サポートする言語を選択します。

**ローカリゼーションタブ**

次回ユーザーがログインするときに、ログイン画面、アカウントコンソール、および管理コンソールに使用する言語をログインページで選択できます。

**追加資料**

* 「サーバー開発者ガイド」では、追加の言語を提供する方法について説明しています。テーマによって提供されるすべての国際化されたテキストは、「ローカリゼーション」タブでレルム固有のテキストで上書きできます。

**ユーザーロケールの選択**

ロケールセレクタープロバイダーは、利用可能な情報に基づいて最適なロケールを提案します。ただし、ユーザーが誰であるか不明なことがよくあります。このため、以前に認証されたユーザーのロケールは、永続化された Cookie に記憶されます。

ロケールを選択するためのロジックでは、使用可能な次のもののうち、最初に一致したものが使用されます。

1. **ユーザーが選択:** ユーザーがドロップダウンロケールセレクターを使用してロケールを選択した場合
2. **ユーザープロファイル:** 認証済みユーザーが存在し、ユーザーが優先ロケールを設定している場合
3. **クライアントが選択:** たとえば、ui\_locales パラメーターを使用してクライアントから渡されたもの
4. **Cookie:** ブラウザで最後に選択されたロケール
5. **承認された言語:** Accept-Language ヘッダーからのロケール
6. **レルムのデフォルト**

上記がいずれも該当しない場合は、英語にフォールバックします。

ユーザーが認証されると、前に説明した永続化された Cookie 内のロケールを更新するアクションがトリガーされます。ユーザーがログインページのロケールセレクターを使用してロケールを積極的に切り替えた場合は、この時点でユーザーのロケールも更新されます。

ロケールを選択するためのロジックを変更する場合は、カスタムの LocaleSelectorProvider を作成することもできます。詳細については、「サーバー開発者ガイド」を参照してください。

### ログインオプションの制御

Keycloak には、いくつかの組み込みのログインページ機能が含まれています。

#### パスワードを忘れた場合の有効化

「パスワードを忘れた場合」を有効にすると、ユーザーはパスワードを忘れた場合や OTP ジェネレーターを紛失した場合に、ログイン認証情報をリセットできます。

**手順**

1. メニューの「レルム設定」をクリックします。
2. 「ログイン」タブをクリックします。

**ログインタブ**

3. 「パスワードを忘れた場合」を「オン」に切り替えます。

ログインページに「パスワードを忘れた場合」リンクが表示されます。

**パスワードを忘れた場合のリンク**

Keycloak がリセットメールを送信できるようにするには、「メール」タブで「ホスト」と「送信者」を指定します。

このリンクをクリックすると、ユーザーはユーザー名またはメールアドレスを入力して、認証情報をリセットするためのリンクが記載されたメールを受け取ることができます。

**パスワードを忘れた場合のページ**

メールで送信されるテキストは構成可能です。詳細については、「サーバー開発者ガイド」を参照してください。

ユーザーがメールのリンクをクリックすると、Keycloak はパスワードの更新をユーザーに求め、OTP ジェネレーターを設定している場合は、OTP ジェネレーターの再構成をユーザーに求めます。組織のセキュリティ要件によっては、ユーザーがメールで OTP ジェネレーターをリセットできないようにすることができます。

この動作を変更するには、次の手順を実行します。

**手順**

1. メニューの「認証」をクリックします。
2. 「フロー」タブをクリックします。
3. 「認証情報の検証」フローを選択します。

**認証情報の検証フロー**

OTP をリセットしない場合は、「リセット - 条件付き OTP」サブフロー要件を「無効」に設定します。

4. メニューの「認証」をクリックします。
5. 「必須アクション」タブをクリックします。
6. 「パスワードの更新」が有効になっていることを確認します。

**必須アクション**

#### 記憶機能の有効化

ログインしているユーザーがブラウザを閉じると、セッションが破棄され、そのユーザーは再びログインする必要があります。ユーザーがログイン時に「記憶する」チェックボックスをクリックした場合に、ユーザーのログインセッションを開いたままにするように Keycloak を設定できます。このアクションにより、ログイン Cookie がセッションのみの Cookie から永続化 Cookie に変わります。

**手順**

1. メニューの「レルム設定」をクリックします。
2. 「ログイン」タブをクリックします。
3. 「記憶する」スイッチを「オン」に切り替えます。

**ログインタブ**

この設定を保存すると、レルムのログインページに「記憶する」チェックボックスが表示されます。

**記憶する**

#### ACR から認証レベル（LoA）へのマッピング

レルムのログイン設定では、どの認証コンテキストクラス参照（ACR）値をどの認証レベル（LoA）にマップするかを定義できます。ACR は任意の値にすることができますが、LoA は数値である必要があります。acr クレームは、OIDC リクエストで送信される claims または acr\_values パラメーターで要求でき、アクセストークンと ID トークンにも含まれています。マップされた番号は、認証フロー条件で使用されます。

特定のクライアントがレルムとは異なる値を使用する必要がある場合は、クライアントレベルでマッピングを指定することもできます。ただし、ベストプラクティスは、レルムマッピングに固執することです。

詳細については、「ステップアップ認証」と「公式 OIDC 仕様」を参照してください。

#### メールの更新ワークフロー（UpdateEmail）

このワークフローでは、ユーザーは UPDATE\_EMAIL アクションを使用して自分のメールアドレスを変更する必要があります。

アクションは、単一のメール入力フォームに関連付けられています。レルムでメールアドレス確認が無効になっている場合、このアクションにより、確認なしでメールを更新できます。レルムでメールアドレス確認が有効になっている場合、アクションはアカウントのメールを変更せずに、新しいメールアドレスにメール更新アクショントークンを送信します。アクショントークンのトリガーのみがメールの更新を完了します。

アプリケーションは、AIA（アプリケーション開始アクション）として UPDATE\_EMAIL を活用することで、ユーザーをメール更新フォームに送信できます。

UpdateEmail はプレビューであり、完全にサポートされているわけではありません。この機能はデフォルトで無効になっています。

有効にするには、--features=preview または --features=update-email を指定してサーバーを起動します。

この機能を有効にし、以前のバージョンから移行する場合は、レルムで「メールの更新」必須アクションを有効にします。有効にしない場合、ユーザーはメールアドレスを更新できません。

### レルムキーの構成

Keycloak で使用される認証プロトコルでは、暗号化署名、場合によっては暗号化が必要です。Keycloak は、非対称鍵ペア（秘密鍵と公開鍵）を使用してこれを実現します。

Keycloak には、一度に 1 つの有効な鍵ペアがありますが、複数のパッシブキーも保持できます。有効な鍵ペアは新しい署名の作成に使用され、パッシブ鍵ペアは以前の署名の検証に使用できます。これにより、ユーザーにダウンタイムや中断を引き起こすことなく、定期的に鍵をローテーションできます。

レルムが作成されると、鍵ペアと自己署名証明書が自動的に生成されます。

**手順**

1. 管理コンソールでレルムを選択します。
2. メニューの「レルム設定」をクリックします。
3. 「鍵」をクリックします。
4. フィルタードロップダウンから「パッシブキー」を選択して、パッシブキーを表示します。
5. フィルタードロップダウンから「無効なキー」を選択して、無効なキーを表示します。

鍵ペアは「有効」ステータスであっても、レルムの現在有効な鍵ペアとして選択されていない可能性があります。署名に使用される選択された有効なペアは、有効な鍵ペアを提供できる最初の鍵プロバイダーに基づいて、優先順位でソートされます。

#### 鍵のローテーション

定期的に鍵をローテーションすることをお勧めします。最初に、既存の有効な鍵よりも優先順位の高い新しい鍵を作成します。代わりに、同じ優先順位で新しい鍵を作成し、以前の鍵をパッシブにすることもできます。

新しい鍵が利用可能になると、すべての新しいトークンと Cookie は新しい鍵で署名されます。ユーザーがアプリケーションに対して認証を行うと、SSO Cookie は新しい署名で更新されます。OpenID Connect トークンが更新されると、新しいトークンは新しい鍵で署名されます。最終的に、すべての Cookie とトークンは新しい鍵を使用するようになり、しばらくすると古い鍵は削除できます。

古い鍵を削除する頻度は、セキュリティと、すべての Cookie とトークンが確実に更新されるようにすることとのトレードオフです。3 ～ 6 か月ごとに新しい鍵を作成し、新しい鍵を作成してから 1 ～ 2 か月後に古い鍵を削除することを検討してください。新しい鍵が追加されてから古い鍵が削除されるまでの間にユーザーが非アクティブだった場合は、そのユーザーは再認証する必要があります。

鍵のローテーションは、オフラインのトークンにも適用されます。更新されていることを確認するには、アプリケーションが古い鍵が削除される前にトークンを更新する必要があります。

#### 生成された鍵ペアの追加

自己署名証明書を含む鍵ペアを生成するには、次の手順に従います。

**手順**

1. 管理コンソールでレルムを選択します。
2. メニューの「レルム設定」をクリックします。
3. 「鍵」タブをクリックします。
4. 「プロバイダー」タブをクリックします。
5. 「プロバイダーの追加」をクリックし、「rsa-generated」を選択します。
6. 「優先度」フィールドに数値を入力します。この数値は、新しい鍵ペアが有効な鍵ペアになるかどうかを決定します。数値が大きいほど、鍵ペアの優先順位が高くなります。
7. 「AES 鍵サイズ」の値を選択します。
8. 「保存」をクリックします。

プロバイダーの優先順位を変更しても鍵は再生成されませんが、鍵サイズを変更する場合は、プロバイダーを編集すると新しい鍵が生成されます。

#### 証明書を抽出して鍵をローテーションする

RSA 生成鍵ペアから証明書を抽出し、その証明書を新しいキーストアで使用することにより、鍵をローテーションできます。

**前提条件**

* 生成された鍵ペア

**手順**

1. 管理コンソールでレルムを選択します。
2. 「レルム設定」をクリックします。
3. 「鍵」タブをクリックします。
4. 「有効」な鍵のリストが表示されます。
5. RSA 鍵の行で、「公開鍵」の「証明書」をクリックします。
6. 証明書がテキスト形式で表示されます。
7. 証明書をファイルに保存し、次の行で囲みます。

```
----Begin Certificate----
<出力>
----End Certificate----
```

8. keytool コマンドを使用して、キーファイルを PEM 形式に変換します。
9. 現在の RSA 公開鍵証明書をキーストアから削除します。

```
keytool -delete -keystore <keystore>.jks -storepass <password> -alias <key>
```

10. 新しい証明書をキーストアにインポートします

```
keytool -importcert -file domain.crt -keystore <keystore>.jks -storepass <password> -alias <key>
```

11. アプリケーションをリビルドします。

```
mvn clean install wildfly:deploy
```

#### 既存の鍵ペアと証明書の追加

別の場所で取得した鍵ペアと証明書を追加するには、「プロバイダー」を選択し、ドロップダウンから「rsa」を選択します。優先順位を変更して、新しい鍵ペアが有効な鍵ペアになるようにすることができます。

**前提条件**

* 秘密鍵ファイル。ファイルは PEM 形式である必要があります。

**手順**

1. 管理コンソールでレルムを選択します。
2. 「レルム設定」をクリックします。
3. 「鍵」タブをクリックします。
4. 「プロバイダー」タブをクリックします。
5. 「プロバイダーの追加」をクリックし、「rsa」を選択します。
6. 「優先度」フィールドに数値を入力します。この数値は、新しい鍵ペアが有効な鍵ペアになるかどうかを決定します。
7. 「秘密 RSA 鍵」の横にある「参照...」をクリックして、秘密鍵ファイルをアップロードします。
8. 秘密鍵の署名付き証明書がある場合は、「X509 証明書」の横にある「参照...」をクリックして、証明書ファイルをアップロードします。証明書をアップロードしない場合、Keycloak は自己署名証明書を自動的に生成します。
9. 「保存」をクリックします。

#### Java キーストアからの鍵の読み込み

ホスト上の Java キーストアファイルに保存されている鍵ペアと証明書を追加するには、「プロバイダー」を選択し、ドロップダウンから「java-keystore」を選択します。優先順位を変更して、新しい鍵ペアが有効な鍵ペアになるようにすることができます。

関連付けられた証明書チェーンを読み込むには、鍵ペアの読み込みに使用されたのと同じ鍵エイリアスを使用して、Java キーストアファイルにインポートする必要があります。

**手順**

1. 管理コンソールでレルムを選択します。
2. メニューの「レルム設定」をクリックします。
3. 「鍵」タブをクリックします。
4. 「プロバイダー」タブをクリックします。
5. 「プロバイダーの追加」をクリックし、「java-keystore」を選択します。
6. 「優先度」フィールドに数値を入力します。この数値は、新しい鍵ペアが有効な鍵ペアになるかどうかを決定します。
7. 「キーストア」の値を入力します。
8. 「キーストアパスワード」の値を入力します。
9. 「鍵エイリアス」の値を入力します。
10. 「鍵パスワード」の値を入力します。
11. 「保存」をクリックします。

#### 鍵をパッシブにする

**手順**

1. 管理コンソールでレルムを選択します。
2. メニューの「レルム設定」をクリックします。
3. 「鍵」タブをクリックします。
4. 「プロバイダー」タブをクリックします。
5. パッシブにする鍵のプロバイダーをクリックします。
6. 「有効」を「オフ」に切り替えます。
7. 「保存」をクリックします。

#### 鍵を無効にする

**手順**

1. 管理コンソールでレルムを選択します。
2. メニューの「レルム設定」をクリックします。
3. 「鍵」タブをクリックします。
4. 「プロバイダー」タブをクリックします。
5. 無効にする鍵のプロバイダーをクリックします。
6. 「有効」を「オフ」に切り替えます。
7. 「保存」をクリックします。

#### 侵害された鍵

Keycloak は、署名鍵をローカルにのみ保存しており、クライアントアプリケーション、ユーザー、またはその他のエンティティと共有されることはありません。ただし、レルムの署名鍵が侵害されたと思われる場合は、最初に上記のように新しい鍵ペアを生成してから、侵害された鍵ペアをすぐに削除する必要があります。

または、「プロバイダー」テーブルからプロバイダーを削除することもできます。

**手順**

1. メニューの「クライアント」をクリックします。
2. 「security-admin-console」をクリックします。
3. 「アクセス設定」セクションまでスクロールダウンします。
4. 「管理 URL」フィールドに入力します。
5. 「詳細」タブをクリックします。
6. 「失効」セクションの「今すぐ設定」をクリックします。
7. 「プッシュ」をクリックします。

not-before ポリシーをプッシュすると、クライアントアプリケーションは、侵害された鍵で署名された既存のトークンを受け入れません。また、クライアントアプリケーションは Keycloak から新しい鍵ペアをダウンロードするように強制されるため、侵害された鍵で署名されたトークンは無効になります。

REST クライアントと機密クライアントは、「管理 URL」を設定して、Keycloak がプッシュされた not-before ポリシーリクエストをクライアントに送信できるようにする必要があります。

## 4. 外部ストレージの利用

<利用していないため、概要のみの説明>
Keycloakは外部ストレージを利用して、既存のユーザーデータベースとの連携を可能にする。LDAPやActive Directoryへの対応はもちろん、Keycloak User Storage SPIを使って独自のユーザーデータベース用の拡張コードを作成することもできる。

ユーザーがログインを試みると、Keycloakはまずそのユーザーのストレージを調べて存在を確認する。見つからない場合は、各ユーザーストレージプロバイダを順番に調べて一致するユーザーを探し、外部データストレージから標準ユーザーモデルに変換する。このモデルは、その後、OIDCトークンクレームやSAMLアサーション属性にマッピングされる。

外部ユーザーデータベースは、Keycloakのすべての機能をサポートするのに必要なデータを持っていないことが多いため、ユーザーストレージプロバイダはKeycloakのユーザーデータストレージにローカルに情報を保存することを選択できる。プロバイダはユーザーをローカルにインポートし、外部データストレージと定期的に同期させることができる。この方法は、プロバイダの機能と設定によって異なる。例えば、外部ユーザーデータストレージがOTPをサポートしていない場合、プロバイダに応じてOTPはKeycloakで処理および保存される。

> ★★★★★★★★★★★★★★★
外部ストレージは利用していないため、詳細は割愛
★★★★★★★★★★★★★★★

## 5. ユーザー管理

管理コンソールから、ユーザー管理に関する様々な操作を実行できます。

### ユーザー作成

ユーザーは、そのユーザーが必要とするアプリケーションが存在するレルムに作成します。マスターレルムは、他のレルムを作成するためのみに使用されるため、マスターレルムにユーザーを作成することは避けてください。

**前提条件:**

* マスターレルム以外のレルムにいること

**手順:**

1. メニューから「ユーザー」をクリックします。
2. 「ユーザー追加」をクリックします。
3. 新しいユーザーの詳細を入力します。
* ユーザー名は必須項目です。
4. 「保存」をクリックします。
* 保存が完了すると、新しいユーザーの管理ページが表示されます。

### ユーザー属性の管理

Keycloakでは、ユーザーは属性のセットに関連付けられます。これらの属性は、Keycloak内でのユーザーの明確な記述と識別、およびアプリケーションへの追加情報の渡すために使用されます。

ユーザープロフィールは、ユーザー属性の表現とレルム内での管理方法に関する明確なスキーマを定義します。ユーザー情報の統一されたビューを提供することで、管理者は属性の管理方法の様々な側面を制御することができ、追加の属性をサポートするためにKeycloakを拡張することを容易にします。

ユーザープロフィールは、エンドユーザーが管理できる属性（氏名、電話番号など）を対象としていますが、ユーザーに関連付けるその他のメタデータの管理にも役立ちます。

ユーザープロフィールは、以下のような機能を提供します。

* ユーザー属性のスキーマの定義
* コンテキスト情報に基づいて属性が必須かどうかを定義（ユーザーのみ、管理者のみ、両方、または要求されるスコープに応じて）
* ユーザー属性の閲覧と編集に関する特定の権限を定義し、一部の属性が第三者（管理者を含む）によって閲覧または変更されないようにするための強力なプライバシー要件を満たすことが可能
* ユーザー情報が常に更新され、属性に関連付けられたメタデータとルールに準拠するように、ユーザープロフィールのコンプライアンスを動的に適用
* 組み込みのバリデーターを利用したり、カスタムバリデーターを作成したりすることで、属性ごとに検証ルールを定義
* 登録、プロフィール更新、ブローカー、アカウントコンソールの個人情報など、ユーザーがやり取りするフォームを属性定義に従って動的にレンダリングし、テーマを手動で変更する必要はありません。
* 管理コンソールのユーザー管理インターフェースをカスタマイズし、属性がユーザープロフィールスキーマに基づいて動的にレンダリングされるようにします。

ユーザープロフィールスキーマまたは構成は、属性とそのメタデータを表現するためにJSON形式を使用します。管理コンソールから、左側のメニューにある「レルム設定」をクリックし、そのページの「ユーザープロフィール」タブをクリックすることで、構成を管理できます。

### ユーザー資格情報の定義

**「資格情報」タブ**でユーザーの資格情報を管理できます。

> ★★★★★★★★★★★★★★★
ユーザー資格情報の定義は利用していないため、詳細は割愛
★★★★★★★★★★★★★★★


### ユーザーによるセルフ登録の許可

Keycloak をサードパーティ認証サーバーとして使用して、アプリケーションユーザー（セルフ登録するユーザーを含む）を管理できます。セルフ登録を有効にすると、ログインページに登録リンクが表示され、ユーザーはアカウントを作成できます。

> ★★★★★★★★★★★★★★★
ユーザーによるセルフ登録の許可は利用していないため、詳細は割愛
★★★★★★★★★★★★★★★

### ログイン時に必要なアクションの定義

ユーザーが初めてログインする際に実行する必要があるアクションを設定できます。これらのアクションは、ユーザーが資格情報を入力した後に行う必要があります。最初のログイン後は、これらのアクションは不要になります。必要なアクションは、そのユーザーの **「詳細」タブ**で追加できます。

> ★★★★★★★★★★★★★★★
ログイン時に必要なアクションの定義は利用していないため、詳細は割愛
★★★★★★★★★★★★★★★

### アプリケーションが開始したアクション

アプリケーションが開始したアクション (AIA) を使用すると、クライアントアプリケーションは Keycloak 側でユーザーにアクションの実行を要求できます。通常、OIDC クライアントアプリケーションはユーザーにログインを求める場合、[OIDC セクション](https://www.keycloak.org/docs/latest/securing_apps/index.html#_openid_connect_oidc) に記載されているようにログイン URL にユーザーをリダイレクトします。ログイン後、ユーザーはクライアントアプリケーションにリダイレクトされます。ユーザーは、[前のセクション](https://www.keycloak.org/docs/latest/securing_apps/index.html#_openid_connect_oidc) に記載されているように、管理者によって要求されたアクションを実行し、その後すぐにアプリケーションにリダイレクトされます。ただし、AIA を使用すると、クライアントアプリケーションはログイン中にユーザーから必要なアクションを要求できます。これは、ユーザーがすでにクライアントで認証済みで、アクティブな SSO セッションを持っている場合でも可能です。これは、**kc_action** パラメータを OIDC ログイン URL に追加し、その値に要求されたアクションを含めることでトリガーされます。たとえば、**kc_action=UPDATE_PASSWORD** パラメータなどです。


> ★★★★★★★★★★★★★★★
アプリケーションが開始したアクションは利用していないため、詳細は割愛
★★★★★★★★★★★★★★★

### ユーザーの検索

ユーザーを検索して、ユーザーのグループやロールなど、ユーザーの詳細情報を確認できます。

**追加リソース**

* ユーザー連邦の詳細については、[ユーザー連邦](https://www.keycloak.org/docs/latest/server_admin/index.html#_user_federation) を参照してください。

### ユーザーの削除

アプリケーションへのアクセス権が不要になったユーザーを削除できます。ユーザーが削除されると、ユーザーのプロファイルとデータも削除されます。

### ユーザーによるアカウント削除の有効化

この機能を管理コンソールで有効にすると、エンドユーザーとアプリケーションはアカウントコンソールで自分のアカウントを削除できます。この機能を有効にしたら、特定のユーザーにその機能を与えることができます。

### ユーザーのなりすまし

適切な権限を持つ管理者は、ユーザーになりすますことができます。たとえば、ユーザーがアプリケーションのバグを経験した場合、管理者はそのユーザーになりすまして問題を調査または再現できます。

### reCAPTCHA の有効化

Keycloak は、ボットから登録を保護するために、Google reCAPTCHA ( [Google reCAPTCHA の設定](https://www.keycloak.org/docs/latest/server_admin/index.html#_setting_up_google_recaptcha) を参照) と reCAPTCHA Enterprise ( [Google reCAPTCHA Enterprise の設定](https://www.keycloak.org/docs/latest/server_admin/index.html#_setting_up_google_recaptcha_enterprise) を参照) と統合されています。デフォルトのテーマ (register.ftl) は、v2 (表示されるチェックボックスベース) と v3 (スコアベースの非表示) の両方の reCAPTCHA をサポートしています ( [適切な reCAPTCHA キーの種類を選択してください](https://developers.google.com/recaptcha/docs/versions) を参照)。

### Keycloak によって収集される個人データ

デフォルトでは、Keycloak は次のデータを収集します。

* ユーザーのメールアドレス、氏名、苗字など、基本的なユーザープロファイルデータ。
* ソーシャルログインを使用する場合、ソーシャルアカウントで使用される基本的なユーザープロファイルデータと、ソーシャルアカウントへの参照。
* IP アドレス、オペレーティングシステム名、ブラウザ名など、監査とセキュリティの目的で収集されるデバイス情報。

Keycloak で収集される情報は、高度にカスタマイズ可能です。カスタマイズを行う場合は、次のガイドラインが適用されます。

* 登録フォームとアカウントフォームには、誕生日、性別、国籍などのカスタムフィールドを含めることができます。管理者は、Keycloak を設定して、ソーシャルプロバイダーまたは LDAP などのユーザーストレージプロバイダーからデータを取得することができます。
* Keycloak は、パスワード、OTP コード、WebAuthn 公開鍵などのユーザー資格情報を収集します。この情報は暗号化されてデータベースに保存されるため、Keycloak 管理者は表示できません。各タイプの資格情報には、パスワードのハッシュに使用されるアルゴリズムや、パスワードのハッシュに使用されるハッシュ反復回数など、管理者が表示できる非機密メタデータを含めることができます。
* 認可サービスと UMA サポートが有効になっている場合、Keycloak は、特定のユーザーが所有者である一部のオブジェクトに関する情報を保持できます。

## 6. Keycloak ユーザーセッション管理

Keycloak は、ユーザーがレルムにログインすると、各ユーザーのユーザーセッションを保持し、そのセッション内でユーザーがアクセスした各クライアントを記憶します。レルム管理者は、各ユーザーセッションに対して、さまざまな操作を実行できます。

* レルムのログイン統計の確認
* アクティブなユーザーとそのログイン場所の確認
* ユーザーのセッションからのログアウト
* トークンの取り消し
* トークンのタイムアウト設定
* セッションのタイムアウト設定

デフォルトでは、オンラインユーザーとオンラインクライアントのセッションはメモリにのみ保持され、メンテナンスまたはアップグレードのためにすべての Keycloak ノードがシャットダウンされると失われます。

`persistent-user-sessions` 機能が有効になっている場合、Keycloak のオンラインユーザーとオンラインクライアントのセッションはデータベースに保存され、再起動やアップグレードにわたって永続化されます。詳細については、**分散キャッシュの構成** を参照してください。

### セッションの管理

Keycloak でアクティブなクライアントとセッションのトップレベルビューを表示するには、メニューから **セッション** をクリックします。

![セッションの画面](画像)

#### アクティブなセッションのすべてをログアウトする

レルム内のすべてのユーザーをログアウトできます。**アクション** リストから **アクティブなセッションのすべてをログアウト** を選択します。すべての SSO クッキーは無効になります。Keycloak は、Keycloak OIDC クライアントアダプターを使用してクライアントにログアウトイベントを通知します。アクティブなブラウザセッション内で認証を要求するクライアントは、再度ログインする必要があります。SAML などのクライアントタイプは、バックチャネルログアウトリクエストを受け取りません。

**アクティブなセッションのすべてをログアウト** をクリックしても、未処理のアクセストークンは取り消されません。未処理のトークンは、自然に期限切れになるまで有効です。Keycloak OIDC クライアントアダプターを使用しているクライアントの場合、トークンを取り消すために **取り消しポリシー** をプッシュできますが、これは他のアダプターでは機能しません。

#### クライアントセッションの表示

1. メニューから **クライアント** をクリックします。
2. **セッション** タブをクリックします。
3. クライアントをクリックして、そのクライアントのセッションを表示します。

![クライアントセッションの画面](画像)

#### ユーザーセッションの表示

1. メニューから **ユーザー** をクリックします。
2. **セッション** タブをクリックします。
3. ユーザーをクリックして、そのユーザーのセッションを表示します。

![ユーザーセッションの画面](画像)

#### アクティブなセッションの取り消し

システムが侵害されている場合は、アクティブなセッションとアクセストークンをすべて取り消すことができます。

1. メニューから **セッション** をクリックします。
2. **アクション** リストから **取り消し** を選択します。

![取り消しの画面](画像)

このコンソールを使用して、指定した日時よりも前に発行されたセッションまたはトークンが無効になる日時と時刻を指定します。

**今すぐ設定** をクリックすると、ポリシーが現在の日時と時刻に設定されます。

**プッシュ** をクリックすると、この取り消しポリシーが、Keycloak OIDC クライアントアダプターを備えた登録済み OIDC クライアントにプッシュされます。

### セッションとトークンのタイムアウト

Keycloak には、**レルム設定** メニューの **セッション** と **トークン** タブを通じて、セッション、クッキー、およびトークンのタイムアウトを制御する機能があります。

#### セッションタブ

![セッションタブの画面](画像)

| 設定 | 説明 |
|---|---|
| SSO セッション アイドル | この設定は、OIDC クライアントのみに適用されます。ユーザーがアイドル状態でこのタイムアウト時間よりも長い間アクティブでない場合、ユーザーセッションは無効になります。このタイムアウト値は、クライアントが認証を要求するか、リフレッシュトークンリクエストを送信するとリセットされます。Keycloak は、セッションが実際に無効になる前に、アイドルタイムアウトに一定の猶予時間を加えます。このセクションの後の **注記** を参照してください。 |
| SSO セッション 最大 | ユーザーセッションが期限切れになるまでの最大時間 |
| SSO セッション アイドル リメンバーミー | この設定は、標準の SSO セッション アイドル構成に似ていますが、**リメンバーミー** を有効にしてログインした場合にのみ適用されます。ユーザーは、ログイン時に **リメンバーミー** をクリックすると、より長いセッションアイドルタイムアウトを指定できます。この設定はオプションの構成であり、値がゼロより大きくない場合は、SSO セッションアイドル構成と同じアイドルタイムアウトを使用します。 |
| SSO セッション 最大 リメンバーミー | この設定は、標準の SSO セッション最大に似ていますが、**リメンバーミー** を有効にしてログインした場合にのみ適用されます。ユーザーは、ログイン時に **リメンバーミー** をクリックすると、より長いセッションを指定できます。この設定はオプションの構成であり、値がゼロより大きくない場合は、SSO セッション最大構成と同じセッションライフタイムを使用します。 |
| クライアントセッション アイドル | クライアントセッションのアイドルタイムアウト。ユーザーがアイドル状態でこのタイムアウト時間よりも長い間アクティブでない場合、クライアントセッションは無効になり、リフレッシュトークンリクエストによってアイドルタイムアウトが延長されます。この設定は、一般の SSO ユーザーセッションには影響しません。一般の SSO ユーザーセッションは、一意です。SSO ユーザーセッションは、ゼロ個以上のクライアントセッションの親であり、ユーザーがログインした異なるクライアントアプリごとに、1つのクライアントセッションが作成されます。この値は、**SSO セッションアイドル** より短いアイドルタイムアウトを指定する必要があります。ユーザーは、**詳細設定** クライアントタブで、個々のクライアントに対してこの設定を上書きできます。この設定はオプションの構成であり、ゼロに設定されている場合は、SSO セッションアイドル構成と同じアイドルタイムアウトを使用します。 |
| クライアントセッション 最大 | クライアントセッションの最大時間、およびリフレッシュトークンが期限切れになって無効になるまでの時間。前のオプションと同様に、この設定は SSO ユーザーセッションには影響せず、**SSO セッション最大** より短い値を指定する必要があります。ユーザーは、**詳細設定** クライアントタブで、個々のクライアントに対してこの設定を上書きできます。この設定はオプションの構成であり、ゼロに設定されている場合は、SSO セッション最大構成と同じ最大タイムアウトを使用します。 |
| オフラインセッション アイドル | この設定は、**オフラインアクセス** に適用されます。Keycloak がオフライントークンを取り消すまでにセッションがアイドル状態を維持する時間。Keycloak は、セッションが実際に無効になる前に、アイドルタイムアウトに一定の猶予時間を加えます。このセクションの後の **注記** を参照してください。 |
| オフラインセッション 最大制限 | この設定は、**オフラインアクセス** に適用されます。このフラグが **有効** の場合、オフラインセッション最大は、ユーザーアクティビティに関係なく、オフライントークンがアクティブな状態を維持できる最大時間を制御できます。このフラグが **無効** の場合、オフラインセッションは、アイドル状態によってのみ期限切れになり、ライフタイムによって期限切れになることはありません。このオプションが有効になると、**オフラインセッション最大**（レルムレベルのグローバルオプション）と **クライアントオフラインセッション最大**（**詳細設定** タブの特定のクライアントレベルオプション）を構成できます。 |
| オフラインセッション 最大 | この設定は、**オフラインアクセス** に適用され、Keycloak が対応するオフライントークンを取り消すまでの最大時間です。このオプションは、ユーザーアクティビティに関係なく、オフライントークンがアクティブな状態を維持できる最大時間を制御します。 |
| ログインタイムアウト | ログインが完了するまでに必要な合計時間。認証がこれよりも長い時間かかる場合、ユーザーは認証プロセスをやり直す必要があります。 |
| ログインアクションタイムアウト | ユーザーが認証プロセス中に、1つのページに滞在できる最大時間 |

#### トークンタブ

![トークンタブの画面](画像)

| 設定 | 説明 |
|---|---|
| デフォルト署名アルゴリズム | レルムのトークンに割り当てるために使用されるデフォルトのアルゴリズム。 |
| リフレッシュトークンの取り消し | **有効** の場合、Keycloak はリフレッシュトークンを取り消し、クライアントが使用する必要がある別のトークンを発行します。このアクションは、リフレッシュトークンフローを実行する OIDC クライアントに適用されます。 |
| アクセストークンライフタイム | Keycloak が OIDC アクセストークンを作成する場合、この値はトークンの有効期間を制御します。 |
| アクセストークンライフタイム（暗黙的フローの場合） | 暗黙的フローの場合、Keycloak はリフレッシュトークンを提供しません。暗黙的フローによって作成されたアクセストークンには、別のタイムアウトがあります。 |
| クライアントログインタイムアウト | クライアントが OIDC の認可コードフローを完了するまでに必要な最大時間。 |
| ユーザーが開始したアクションの有効期間 | ユーザーのアクション権限が期限切れになるまでの最大時間。ユーザーは通常、自分自身で作成したアクションにすぐに対応するため、この値は短くしてください。 |
| デフォルトの管理者が開始したアクションの有効期間 | 管理者からユーザーに送信されたアクション権限が期限切れになるまでの最大時間。オフラインユーザーにメールを送信できるように、この値は長くしてください。管理者は、トークンを発行する前に、デフォルトのタイムアウトを上書きできます。 |
| メール確認 | メール確認の独立したタイムアウトを指定します。 |
| IdP アカウントメール確認 | IdP アカウントメール確認の独立したタイムアウトを指定します。 |
| パスワードの忘れ忘れ | パスワードの忘れ忘れの独立したタイムアウトを指定します。 |
| アクションの実行 | アクションの実行の独立したタイムアウトを指定します。 |

アイドルタイムアウトの場合、セッションがアクティブな状態を維持する 2 分の猶予時間があります。たとえば、タイムアウトを 30 分に設定した場合、セッションが期限切れになるまでには 32 分かかります。

このアクションは、トークンが期限切れになる直前に 1 つのクラスタノードでトークンが更新され、他のクラスタノードが更新メッセージを受信していないため、セッションが期限切れと誤って判断される、クラスタ環境やクロスデータセンター環境での特定のシナリオに必要なものです。

### オフラインアクセス

オフラインアクセスは、ユーザーがオンラインでなくても、クライアントアプリケーションがユーザーの代わりにオフラインで操作を実行できるようにする機能です。例えば、定期的なデータバックアップなどが挙げられます。

オフラインアクセスでは、クライアントアプリケーションはリフレッシュトークンではなく、**オフライントークン**を要求します。このオフライントークンは、クライアントアプリケーションによって保存され、ユーザーがログアウトした場合でも、将来のログインに使用することができます。

オフライントークンは、リフレッシュトークンとは異なり、期限切れにならず、SSOセッションのアイドルタイムアウトや最大有効期間の影響を受けません。ユーザーがログアウトしたり、サーバーが再起動したりしても、オフライントークンは有効です。ただし、30日ごと、または `Offline Session Idle` の値の間隔で、オフライントークンをリフレッシュトークンとして使用して、新しいアクセストークンを取得する必要があります。

> ★★★★★★★★★★★★★★★
オフラインアクセスは利用していないため、詳細は割愛
★★★★★★★★★★★★★★★



### トランジェントセッション

Keycloakでは、**トランジェントセッション**を実行できます。トランジェントセッションを使用する場合、Keycloakは、認証が成功した後、ユーザーセッションを作成しません。Keycloakは、ユーザーを認証した現在のリクエストの範囲で、一時的なトランジェントセッションを作成します。Keycloakは、認証後に、トランジェントセッションを使用して、**プロトコルマッパー**を実行できます。

> ★★★★★★★★★★★★★★★
トランジェントセッションは利用していないため、詳細は割愛
★★★★★★★★★★★★★★★

## 7. ロールとグループを使用した権限の割り当て

ロールとグループは、ユーザーにアプリケーションの使用権限を与えるという似た目的を持っています。グループは、ロールと属性を適用するユーザーの集まりです。ロールは、特定のアプリケーションの権限とアクセス制御を定義します。

一般的に、ロールは特定の種類のユーザーに適用されます。例えば、組織には、管理者、ユーザー、マネージャー、従業員などのロールが含まれる場合があります。アプリケーションは、ロールにアクセス権限を割り当て、その後、複数のユーザーをそのロールに割り当てることができます。これにより、ユーザーは同じアクセス権限を持つようになります。例えば、管理者コンソールには、ユーザーが管理者コンソールの異なる部分にアクセスするための権限を与えるロールがあります。

ロールにはグローバル名前空間があり、各クライアントも独自の専用のロール定義名前空間を持っています。

> ★★★★★★★★★★★★★★★
ロールとグループを使用した権限の割り当ては利用していないため、詳細は割愛
★★★★★★★★★★★★★★★

## 8. 認証設定

本章では、認証に関するいくつかのトピックについて解説します。

* **厳格なパスワードポリシーとワンタイムパスワード（OTP）ポリシーの適用**
* **異なる認証情報タイプの管理**
* **Kerberosでのログイン**
* **組み込みの認証情報タイプの無効化と有効化**

### パスワードポリシー

Keycloakでレルムを作成すると、レルムにパスワードポリシーは関連付けられません。つまり、パスワードの長さ、セキュリティ、複雑さに関する制限なしに、簡単なパスワードを設定することができます。本番環境では、簡単なパスワードは許容されません。Keycloakは、管理コンソールを通じて利用可能なパスワードポリシーのセットを提供しています。

> ★★★★★★★★★★★★★★★
パスワードポリシーは利用していないため、詳細は割愛
★★★★★★★★★★★★★★★

### ワンタイムパスワード（OTP）ポリシー

Keycloakには、FreeOTPまたはGoogle Authenticatorワンタイムパスワードジェネレーターを設定するためのいくつかのポリシーがあります。

> ★★★★★★★★★★★★★★★
ワンタイムパスワード（OTP）ポリシーは利用していないため、詳細は割愛
★★★★★★★★★★★★★★★

### 認証フローについて

**認証フロー**とは、ログイン、登録、その他のKeycloakワークフローにおいて、認証、画面表示、処理をまとめたものです。

> ★★★★★★★★★★★★★★★
カスタム認証フローは利用しないため、詳細は割愛
★★★★★★★★★★★★★★★

### Keycloak のユーザーセッション制限について

このドキュメントは、Keycloak でユーザーセッション数を制限する方法について説明します。

#### セッション制限の設定

1. **フローにステップを追加する:** フローに追加するステップとして「ユーザーセッション数制限」を選択します。
2. **ユーザーセッション数制限を必須にする:** 「ユーザーセッション数制限」の認証タイプを「必須」に設定します。
3. **設定を編集する:** 「ユーザーセッション数制限」の歯車アイコンをクリックし、以下を設定します。
- **エイリアス:** この設定のエイリアスを入力します。
- **セッション数の最大値:** リアルム全体でユーザーが持つことができるセッション数の最大値を入力します。例えば、値が 2 の場合、ユーザーはリアルム内で最大 2 つの SSO セッションを持つことができます。値が 0 の場合は、このチェックは無効になります。
- **クライアントごとのセッション数の最大値:** クライアントごとにユーザーが持つことができるセッション数の最大値を入力します。例えば、値が 2 の場合、ユーザーはクライアント `foo` に対して最大 2 つの SSO セッションを持つことができます。ユーザーがすでにクライアント `foo` に対して 2 つの SSO セッションを持っている状態で認証を試みると、認証が拒否されるか、設定された動作に基づいて既存のセッションが終了します。値が 0 の場合は、このチェックは無効になります。
- **セッション制限とクライアントセッション制限の両方** を有効にする場合は、クライアントセッション制限が常にセッション制限よりも低くなるようにしてください。クライアントごとの制限は、ユーザーのすべての SSO セッションの制限を超えることはできません。
4. **制限に達した場合の動作を選択する:**
- **新しいセッションを拒否:** セッション制限に達した状態で新しいセッションが要求された場合、新しいセッションは作成されません。
- **最も古いセッションを終了:** セッション制限に達した状態で新しいセッションが要求された場合、最も古いセッションが削除され、新しいセッションが作成されます。
5. **カスタムエラーメッセージを追加する:** 必要に応じて、制限に達したときに表示されるカスタムエラーメッセージを追加します。

#### フローへの追加

ユーザーセッション制限は、以下のフローに追加する必要があります。

- **ブラウザフロー:** 最上位レベルのフローには追加しないでください。これは、SSO Cookie に基づいてユーザーを自動的に再認証する Cookie 認証が存在するためです。最上位レベルでセッション制限をチェックすると、すでにユーザーセッションが存在するため、適切ではありません。代わりに、Cookie と同じレベルに別々の ALTERNATIVE サブフロー（例：`authenticate-user-with-session-limit`）を追加し、そのサブフロー内に REQUIRED サブフロー（例：`real-authentication-subflow`）を追加し、そこにユーザーセッション制限を追加してください。`real-authentication-subflow` 内には、デフォルトのブラウザフローと同様に実際の認証を追加できます。
- **ダイレクトグラントフロー:** 認証フローの最後に REQUIRED として追加してください。
- **パスワードリセット:** 認証フローの最後に REQUIRED として追加してください。
- **ポストブローカーログインフロー:** 認証フローの唯一の認証として追加してください。ただし、このフローが ID プロバイダーでポストブローカーフローとして設定されていることを確認してください。これは、ID プロバイダーによる認証もセッション制限の対象となるようにするためです。

#### 注意事項

- 各フローでユーザーセッション制限の設定が一致していることを確認してください。
- ユーザーセッション制限機能は、CIBA では使用できません。


### スクリプト認証

管理コンソールと REST エンドポイントを通じてスクリプトをアップロードする機能は非推奨となっています。

### Kerberos

Keycloak は、Simple and Protected GSSAPI Negotiation Mechanism (SPNEGO) プロトコルを通じて、Kerberos チケットを使用したログインをサポートしています。 SPNEGO は、ユーザーがセッションを認証した後、Web ブラウザを通じて透過的に認証を行います。 Web 以外のケース、またはログイン中にチケットが利用できない場合、Keycloak は Kerberos のユーザー名とパスワードを使用したログインをサポートしています。

> ★★★★★★★★★★★★★★★
Kerberosは利用しないため、詳細は割愛
★★★★★★★★★★★★★★★

### X.509 クライアント証明書ユーザー認証

Keycloak は、サーバーで相互 SSL 認証が設定されている場合、X.509 クライアント証明書を使用したログインをサポートしています。

> ★★★★★★★★★★★★★★★
X.509 クライアント証明書ユーザー認証は利用しないため、詳細は割愛
★★★★★★★★★★★★★★★

### W3C Web 認証 (WebAuthn)

Keycloak は、W3C Web 認証 (WebAuthn) をサポートしています。 Keycloak は、WebAuthn の Relying Party (RP) として機能します。

> ★★★★★★★★★★★★★★★
W3C Web 認証 (WebAuthn)は利用しないため、詳細は割愛
★★★★★★★★★★★★★★★

### パスキー

Keycloak は、パスキーのプレビューサポートを提供しています。 Keycloak は、パスキー Relying Party (RP) として機能します。

> ★★★★★★★★★★★★★★★
パスキーは利用しないため、詳細は割愛
★★★★★★★★★★★★★★★

### リカバリコード (RecoveryCodes)

認証フローに「リカバリ認証コードフォーム」を 2 要素認証子として追加することで、リカバリコードを 2 要素認証用に設定できます。 この認証子の設定例については、WebAuthn を参照してください。

> ★★★★★★★★★★★★★★★
リカバリコード (RecoveryCodes)は利用しないため、詳細は割愛
★★★★★★★★★★★★★★★

### 条件付きフローの条件

実行要件で説明したように、条件の実行は、条件付きサブフローにのみ含まれることができます。 すべての条件の実行が true と評価された場合、条件付きサブフローは必須として動作します。 条件付きサブフローの次の実行を処理できます。 条件付きサブフローに含まれる実行の一部が false と評価された場合、サブフロー全体は無効と見なされます。

> ★★★★★★★★★★★★★★★
条件付きフローの条件は利用しないため、詳細は割愛
★★★★★★★★★★★★★★★

### 認証セッション

Web ブラウザでログインページが初めて開かれると、Keycloak は認証セッションと呼ばれるオブジェクトを作成し、要求に関するいくつかの便利な情報を格納します。 同じブラウザの別のタブから新しいログインページが開かれるたびに、Keycloak は認証セッション内に格納される認証サブセッションと呼ばれる新しいレコードを作成します。 認証要求は、管理 CLI などの任意のタイプのクライアントから来る可能性があります。 この場合、新しい認証セッションも 1 つの認証サブセッションで作成されます。 認証セッションは、ブラウザフローを使用する以外に、他の方法でも作成できることに注意してください。

認証セッションは通常、デフォルトでは 30 分後に期限切れになります。 正確な時間は、管理コンソールのセッションタブにあるログインタイムアウトスイッチで、レルムを設定するときに指定されます。

**複数のブラウザタブでの認証**

前のセクションで説明したように、ユーザーが単一のブラウザの複数のタブから Keycloak サーバーに認証しようとすると、状況が発生する可能性があります。 ただし、ユーザーが 1 つのブラウザタブで認証すると、他のブラウザタブは自動的に認証を再開します。 この認証は、Keycloak ログインページにある小さな JavaScript により発生します。 再開は通常、ユーザーを他のブラウザタブで認証し、クライアントにリダイレクトします。これは、ユーザーが最初のブラウザタブで正常に認証したため、現在 SSO セッションがあるためです。 ただし、OIDC パラメータ prompt=login または step-up 認証を使用して、現在認証されているファクターよりも強力な認証ファクターを要求する場合など、ユーザーが他のブラウザタブで自動的に認証されないまれな例外があります。

まれなケースでは、最初のブラウザタブで認証した後、他のブラウザタブが認証セッションが既に期限切れであるため、認証を再開できない場合があります。 この場合、特定のブラウザタブは、期限切れの認証セッションに関するエラーを、プロトコル固有の方法でクライアントにリダイレクトします。 詳細については、OIDC ドキュメントと SAML ドキュメントの対応するセクションを参照してください。 クライアントアプリケーションがこのようなエラーを受け取ると、OIDC/SAML 認証要求を Keycloak にすぐに再送信できます。これは、以前説明したように、既存の SSO セッションのために、通常は自動的にユーザーを認証する必要があります。 その結果、エンドユーザーはすべてのブラウザタブで自動的に認証されます。 Keycloak JavaScript アダプター、Keycloak SAML アダプター、Keycloak ID プロバイダーは、このような場合に自動的にこのエラーを処理し、Keycloak サーバーへの認証を再試行するサポートを提供します。

## 9. Keycloakにおけるアイデンティティプロバイダーの統合

**アイデンティティブローカーとは、サービスプロバイダーとアイデンティティプロバイダーを繋ぐ仲介サービスです。** アイデンティティブローカーは外部のアイデンティティプロバイダーとの関係を構築し、プロバイダーのアイデンティティを使用して、サービスプロバイダーが公開する内部サービスにアクセスできるようにします。

**ユーザーの視点から見ると、アイデンティティブローカーは、セキュリティドメインとレルムのアイデンティティを管理するための、ユーザー中心で一元化された方法を提供します。** ユーザーは、アイデンティティプロバイダーからの1つ以上のアイデンティティでアカウントをリンクしたり、アイデンティティプロバイダーからのアイデンティティ情報に基づいてアカウントを作成したりできます。

**アイデンティティプロバイダーは、ユーザーの認証と認証・認可情報の送信に使用される特定のプロトコルに由来します。** アイデンティティプロバイダーは、以下のようなものがあります。

* **ソーシャルプロバイダー:** Facebook、Google、Twitterなど
* **ビジネスパートナー:** ユーザーがサービスにアクセスする必要があるビジネスパートナー
* **クラウドベースのアイデンティティサービス:** 統合したいクラウドベースのアイデンティティサービス

**通常、Keycloakはアイデンティティプロバイダーを次のプロトコルに基づいています。**

* SAML v2.0
* OpenID Connect v1.0
* OAuth v2.0

### ブローカーの概要

Keycloakをアイデンティティブローカーとして使用する場合、Keycloakはユーザーに特定のレルムで認証するための資格情報の提供を強制しません。 Keycloakは、ユーザーが認証できるアイデンティティプロバイダーのリストを表示します。

**デフォルトのアイデンティティプロバイダーを設定すると、Keycloakはユーザーをデフォルトのプロバイダーにリダイレクトします。**

**異なるプロトコルでは、異なる認証フローが必要となる場合があります。** Keycloakでサポートされているすべてのアイデンティティプロバイダーは、次のフローを使用します。

### アイデンティティブローカーフロー

1. **認証されていないユーザーが、クライアントアプリケーション内の保護されたリソースを要求します。**
2. **クライアントアプリケーションは、ユーザーをKeycloakにリダイレクトして認証します。**
3. **Keycloakは、レルムに設定されているアイデンティティプロバイダーのリストを含むログインページを表示します。**
4. **ユーザーは、ボタンまたはリンクをクリックして、アイデンティティプロバイダーのいずれかを選択します。**
5. **Keycloakは、認証を要求するターゲットアイデンティティプロバイダーに認証要求を発行し、ユーザーをアイデンティティプロバイダーのログインページにリダイレクトします。** 管理者は、管理コンソールのアイデンティティプロバイダーについて、接続プロパティとその他の構成オプションを既に設定しています。
6. **ユーザーは、アイデンティティプロバイダーで認証するために、資格情報を入力するか、同意します。**
7. **アイデンティティプロバイダーによる認証が成功すると、ユーザーは認証応答とともにKeycloakにリダイレクトされます。** 通常、応答には、Keycloakがアイデンティティプロバイダーの認証を信頼し、ユーザー情報を取得するために使用するセキュリティトークンが含まれています。
8. **Keycloakは、アイデンティティプロバイダーからの応答が有効かどうかを確認します。** 有効な場合は、ユーザーが存在しない場合は、Keycloakはユーザーをインポートして作成します。 トークンにユーザー情報が含まれていない場合は、Keycloakはアイデンティティプロバイダーにユーザー情報の追加を要求する場合があります。 この動作は**アイデンティティフェデレーション**です。 ユーザーが既に存在する場合は、Keycloakはユーザーに、アイデンティティプロバイダーから返されたアイデンティティを既存のアカウントにリンクするよう求める場合があります。 この動作は**アカウントリンク**です。 Keycloakでは、**アカウントリンク**を設定し、**ファーストログインフロー**で指定することができます。 このステップで、Keycloakはユーザーを認証し、サービスプロバイダー内の要求されたリソースにアクセスするためのトークンを発行します。
9. **ユーザーが認証されると、Keycloakは、ローカル認証中に発行されたトークンを送信して、ユーザーをサービスプロバイダーにリダイレクトします。**
10. **サービスプロバイダーはKeycloakからトークンを受け取り、保護されたリソースへのアクセスを許可します。**

このフローのバリエーションは可能です。 例えば、クライアントアプリケーションは、アイデンティティプロバイダーのリストを表示するのではなく、特定のアイデンティティプロバイダーを要求したり、Keycloakでユーザーにアイデンティティをフェデレートする前に追加情報を提供することを強制したりすることができます。

**認証プロセスが終了すると、Keycloakはクライアントアプリケーションにトークンを発行します。** クライアントアプリケーションは外部のアイデンティティプロバイダーとは別であるため、クライアントアプリケーションのプロトコルやユーザーのアイデンティティの検証方法を見ることができません。 プロバイダーは、Keycloakについてのみ知る必要があります。

**デフォルトのアイデンティティプロバイダー**

Keycloakは、ログインフォームを表示するのではなく、アイデンティティプロバイダーにリダイレクトできます。 このリダイレクトを有効にするには、次の手順を実行します。

1. メニューの**認証**をクリックします。
2. **ブラウザ**フローをクリックします。
3. **アイデンティティプロバイダーリダイレクター**行の歯車アイコン⚙️をクリックします。
4. **デフォルトのアイデンティティプロバイダー**を、ユーザーをリダイレクトするアイデンティティプロバイダーに設定します。

**Keycloakが設定されたデフォルトのアイデンティティプロバイダーを見つけられない場合は、ログインフォームが表示されます。**

この認証子は、`kc_idp_hint`クエリパラメーターの処理を担当します。 詳細については、**クライアントが提案したアイデンティティプロバイダー**セクションを参照してください。

### 一般的な構成

アイデンティティブローカー構成の基礎は、アイデンティティプロバイダー（IDP）です。 Keycloakは各レルムにアイデンティティプロバイダーを作成し、デフォルトですべてのアプリケーションに対して有効化します。 レルムのユーザーは、アプリケーションにサインインする際に、登録されているアイデンティティプロバイダーのいずれかを使用できます。

**アイデンティティプロバイダーを構成すると、ログインページでオプションとして表示されます。** 各アイデンティティプロバイダーのログイン画面にカスタムアイコンを配置することができます。 詳細については、**カスタムアイコン**を参照してください。

**IDPログインページ**

**ソーシャル**

ソーシャルプロバイダーは、レルムでソーシャル認証を可能にします。 Keycloakを使用すると、ユーザーはソーシャルネットワークアカウントを使用してアプリケーションにログインできます。 サポートされているプロバイダーには、Twitter、Facebook、Google、LinkedIn、Instagram、Microsoft、PayPal、Openshift v3、GitHub、GitLab、Bitbucket、Stack Overflowなどがあります。

**プロトコルベース**

プロトコルベースのプロバイダーは、ユーザーを認証および認可するために、特定のプロトコルに依存します。 これらのプロバイダーを使用すると、特定のプロトコルに準拠した任意のアイデンティティプロバイダーに接続することができます。 Keycloakは、SAML v2.0およびOpenID Connect v1.0プロトコルをサポートしています。 これらのオープンスタンダードに基づいて、任意のアイデンティティプロバイダーを構成およびブローカーすることができます。

**各タイプのアイデンティティプロバイダーには独自の構成オプションがありますが、すべて共通の構成を共有しています。** 使用可能な構成オプションは以下のとおりです。

**表1. 共通構成**

| 構成 | 説明 |
|--------------------------|-----------------------------------------------------------------------------------|
| **エイリアス** | アイデンティティプロバイダーを一意に識別するものであり、内部のアイデンティティプロバイダーを参照します。 Keycloakは、エイリアスを使用して、アイデンティティプロバイダーと通信するためにリダイレクトURIまたはコールバックURLを必要とするOpenID Connectプロトコル用のリダイレクトURIを構築します。 すべてのアイデンティティプロバイダーにはエイリアスが必要です。 エイリアスの例には、`facebook`、`google`、`idp.acme.com`などがあります。 |
| **有効化** | プロバイダーをONまたはOFFにします。 |
| **ログインページに非表示** | ONの場合、Keycloakはログインページでこのプロバイダーをログインオプションとして表示しません。 クライアントは、URLに`kc_idp_hint`パラメータを使用することで、このプロバイダーを要求することができます。 |
| **アカウントリンクのみ** | ONの場合、Keycloakは既存のアカウントをこのプロバイダーにリンクします。 このプロバイダーはユーザーをログインさせることができず、Keycloakはログインページでこのプロバイダーをオプションとして表示しません。 |
| **トークンの保存** | ONの場合、Keycloakはアイデンティティプロバイダーからのトークンを保存します。 |
| **保存されたトークンの読み取り可能** | ONの場合、ユーザーは保存されたアイデンティティプロバイダートークンを取得できます。 このアクションは、`broker`クライアントレベルのロールの`read token`にも適用されます。 |
| **メールの信頼** | ONの場合、Keycloakはアイデンティティプロバイダーからのメールアドレスを信頼します。 レルムでメールの検証が要求されている場合、このアイデンティティプロバイダーからログインしたユーザーは、メール検証プロセスを実行する必要がありません。 |
| **GUIの順序** | ログインページで利用可能なアイデンティティプロバイダーのソート順序。 |
| **必須のクレームの検証** | ONの場合、アイデンティティプロバイダーによって発行されたIDトークンには、特定のクレームが含まれている必要があります。 そうしないと、ユーザーはこのブローカーを通じて認証できません。 |
| **必須のクレーム** | `必須のクレームの検証`がONの場合、フィルターするJWTトークンクレームの名前 (マッチはケースセンシティブ)。 |
| **必須のクレームの値** | `必須のクレームの検証`がONの場合、マッチするJWTトークンクレームの値 (正規表現形式をサポート)。 |
| **ファーストログインフロー** | ユーザーがこのアイデンティティプロバイダーを使用して初めてKeycloakにログインする際に、Keycloakがトリガーする認証フロー。 |
| **ログイン後のフロー** | ユーザーが外部のアイデンティティプロバイダーでのログインを完了した際に、Keycloakがトリガーする認証フロー。 |
| **同期モード** | マッパーを通じてアイデンティティプロバイダーからユーザー情報を更新するための戦略。 `legacy`を選択した場合、Keycloakは現在の動作を使用します。 `import`はユーザーデータを更新せず、`force`は可能な限りユーザーデータを更新します。 詳細については、**アイデンティティプロバイダーマッパー**を参照してください。 |
| **ケースセンシティブなユーザー名** | 有効な場合、アイデンティティプロバイダーからの元のユーザー名は、ユーザーをフェデレートする際にそのまま保持されます。 そうでない場合、アイデンティティプロバイダーからのユーザー名は小文字に変換され、ケースセンシティブな場合は元の値と一致しない場合があります。 この設定は、サーバーのユーザー名は常に小文字であるため、フェデレートされたアイデンティティに関連付けられたユーザー名にのみ影響します。 |

### ソーシャルアイデンティティプロバイダー

ソーシャルアイデンティティプロバイダーは、信頼できる、評判の良いソーシャルメディアアカウントに認証を委任できます。Keycloakは、Google、Facebook、Twitter、GitHub、LinkedIn、Microsoft、Stack Overflowなどのソーシャルネットワークをサポートしています。

#### サポートされているソーシャルメディアアカウント

- Bitbucket
- Facebook
- GitHub
- GitLab
- Google
- Instagram
- LinkedIn
- Microsoft
- OpenShift 3
- OpenShift 4
- PayPal
- Stack Overflow
- Twitter

#### Microsoftアイデンティティプロバイダーの追加手順

1. メニューから「アイデンティティプロバイダー」をクリックします。
2. 「プロバイダーを追加」リストから「Microsoft」を選択します。
3. 「リダイレクトURI」の値をクリップボードにコピーします。
4. 別のブラウザタブで、Microsoft Azureの「アプリの登録」の下にアプリを登録します。
5. 「リダイレクトURI」セクションで、プラットフォームとして「Web」を選択し、「リダイレクトURI」の値をフィールドに貼り付けます。
6. 「アプリの登録」の下にあるアプリケーションを見つけ、「証明書と秘密」セクションで新しいクライアントシークレットを追加します。
7. 作成されたシークレットの「値」をメモします。
8. 「概要」セクションで「アプリケーション（クライアント）ID」をメモします。
9. Keycloakで、「アプリケーション（クライアント）ID」の値を「クライアントID」フィールドに貼り付けます。
10. Keycloakで、シークレットの「値」を「クライアントシークレット」フィールドに貼り付けます。
11. 「追加」をクリックします。

### OpenID Connect v1.0 アイデンティティプロバイダー

Keycloakは、OpenID Connectプロトコルに基づいたアイデンティティプロバイダーを仲介します。これらのアイデンティティプロバイダー（IDP）は、ユーザーを認証し、アクセスを承認するために、仕様で定義された「承認コードフロー」をサポートする必要があります。

> ★★★★★★★★★★★★★★★
独自のOpenID Connect v1.0 アイデンティティプロバイダーは利用しないため、詳細は割愛
★★★★★★★★★★★★★★★

### SAML v2.0 アイデンティティプロバイダー

Keycloakは、SAML v2.0プロトコルに基づいたアイデンティティプロバイダーを仲介できます。

> ★★★★★★★★★★★★★★★
独自のSAML v2.0 アイデンティティプロバイダーは利用しないため、詳細は割愛
★★★★★★★★★★★★★★★

### クライアントによるIDプロバイダー指定**

OIDCアプリケーションは、Keycloakのログインページをスキップして、利用したいIDプロバイダーを指定することができます。これは、**`kc_idp_hint`** クエリパラメータをAuthorization Code Flowの認可エンドポイントに設定することで実現できます。これにより、ユーザーはKeycloakのログインページに遷移することなく、直接IDプロバイダーのログインページにアクセスできます。

### クレームとアサーションのマッピング**

Keycloakは、外部IDプロバイダーのSAMLおよびOpenID Connectメタデータを取り込む機能を備えています。メタデータを取り込むことで、ユーザーのプロファイル情報やその他の情報を取得し、アプリケーションで使用できるようにすることができます。

### ユーザーセッションデータ

外部IDPからのログイン後、Keycloakはユーザーセッションに関する情報を保存します。この情報は、適切なクライアントマッパーを使用してトークンやSAMLアサーションを通じて、ログインを要求したクライアントに伝達できます。

* **identity_provider**: ログインに使用されたブローカーのIDPエイリアスです。
* **identity_provider_identity**: 認証されたユーザーのIDPユーザー名です。Keycloakユーザー名と同じですが、必ずしも一致するとは限りません。例えば、KeycloakはKeycloakユーザー"john"をFacebookユーザー"john123@gmail.com"にリンクできます。この場合、ユーザーセッションデータの値は"john123@gmail.com"になります。

**ユーザーセッションデータは、プロトコルマッパーの「User Session Note」タイプを使用してクライアントに伝達できます。**

### ファーストログインフロー

ユーザーがIDPブローカーを通じてログインすると、Keycloakはユーザーの情報をレルムのローカルデータベースにインポートしてリンクします。外部IDPによる認証が成功すると、次の2つの状況が発生する可能性があります。

1. **Keycloakがすでに認証されたIDPアカウントとユーザーアカウントをインポートしてリンク済み**：この場合、Keycloakは既存のユーザーとして認証を行い、アプリケーションにリダイレクトします。
2. **Keycloakにユーザーのアカウントが存在しない**：通常、新しいアカウントをKeycloakデータベースに登録してインポートしますが、同じメールアドレスを持つ既存のKeycloakアカウントが存在する場合があります。既存のローカルアカウントを外部IDPに自動的にリンクすると、セキュリティ上の脆弱性になる可能性があります。外部IDPから取得した情報が常に信頼できるわけではありません。

これらの状況への対応方法は組織によって異なります。Keycloakでは、IDP設定の**ファーストログインフロー**オプションを使用して、外部IDPからの初めてのログイン時のワークフローを選択できます。デフォルトでは、**ファーストログインフロー**オプションは**最初のブローカーログイン**フローを指しますが、独自のフローや、IDPごとに異なるフローを使用できます。

フローは管理コンソールの**認証**タブにあります。**最初のブローカーログイン**フローを選択すると、デフォルトで使用されるオーセンティケーターが表示されます。既存のフローを再構成できます。例えば、一部のオーセンティケーターを無効にしたり、必須としてマークしたり、オーセンティケーターを構成したりできます。

また、新しい認証フローを作成したり、独自のオーセンティケーター実装を作成してフローで使用したりすることもできます。詳細については、サーバー開発者ガイドを参照してください。

#### デフォルトのファーストログインフローオーセンティケーター

* **プロフィール確認**: このオーセンティケーターは、プロフィール情報ページを表示します。ユーザーは、KeycloakがIDPから取得したプロフィールを確認できます。
* **最初のログイン時にプロフィールを更新**: **アクション**メニューでこのオプションを設定できます。
* **有効**: ユーザーに、IDを統合するために追加情報を入力するように求めるプロフィールページが表示されます。
* **欠落**: IDPがメールアドレス、氏名などの必須情報を提供しない場合、ユーザーにプロフィールページが表示されます。
* **無効**: プロフィールページは、ユーザーが**プロフィール情報の確認**リンク（**既存アカウントのリンク確認**オーセンティケーターによって表示されるページの後半にある）をクリックした場合にのみ表示されます。
* **ユニークな場合にユーザーを作成**: このオーセンティケーターは、IDPのアカウントと同じメールアドレスまたはユーザー名を持つKeycloakアカウントがすでに存在するかどうかを確認します。存在しない場合は、新しいローカルKeycloakアカウントを作成してIDPにリンクし、フロー全体が完了します。存在する場合は、次の**既存アカウントの処理**サブフローに進みます。常に重複アカウントがないことを保証したい場合は、このオーセンティケーターを**必須**としてマークできます。この場合、既存のKeycloakアカウントが存在するとエラーページが表示され、ユーザーはアカウント管理を通じてIDPアカウントをリンクする必要があります。
* **IDPアカウントと同じメールアドレスまたはユーザー名を持つKeycloakアカウントが存在するかどうかを確認します。**
* **アカウントが存在しない場合**: オーセンティケーターはローカルKeycloakアカウントを作成し、IDPにリンクしてフローを終了します。
* **アカウントが存在する場合**: オーセンティケーターは次の**既存アカウントの処理**サブフローを実行します。
* **重複アカウントを防止するために、このオーセンティケーターを**必須**としてマークできます。Keycloakアカウントが存在するとエラーページが表示され、ユーザーはアカウント管理を通じてIDPアカウントをリンクする必要があります。
* **既存アカウントのリンク確認**: 情報ページで、ユーザーは同じメールアドレスを持つKeycloakアカウントを見ることができます。ユーザーは再度プロフィールを確認し、別のメールアドレスまたはユーザー名を使用できます。フローが再起動し、**プロフィール確認**オーセンティケーターに戻ります。
* あるいは、ユーザーはIDPアカウントを既存のKeycloakアカウントにリンクすることを確認できます。
* ユーザーにこの確認ページを表示せず、メール確認または再認証によって直接IDPアカウントをリンクさせたい場合は、このオーセンティケーターを無効にしてください。
* **メールによる既存アカウントの確認**: このオーセンティケーターはデフォルトで**代替**です。レルムにSMTP設定が構成されている場合、Keycloakはこのオーセンティケーターを使用します。
* オーセンティケーターはユーザーにメールを送信し、IDPをKeycloakアカウントにリンクすることを確認します。
* メールによるリンク確認を行わず、ユーザーにパスワードで再認証させたい場合は、このオーセンティケーターを無効にしてください。
* **再認証による既存アカウントの確認**: このオーセンティケーターは、メールオーセンティケーターが使用できない場合に使用します。例えば、レルムにSMTPが構成されていない場合です。このオーセンティケーターはユーザーにログイン画面を表示し、KeycloakアカウントをIDPにリンクするために認証を行います。
* ユーザーは、すでにKeycloakアカウントにリンクされている別のIDPで再認証することもできます。
* OTPの使用を強制できます。それ以外の場合は、オプションであり、ユーザーアカウントにOTPを設定している場合に使用されます。
* **自動既存ユーザーリンク**: AutoLinkオーセンティケーターは、ユーザーが任意のユーザー名またはメールアドレスを使用して自分自身を登録できる一般的な環境では危険です。ユーザー登録を慎重に管理し、ユーザー名とメールアドレスを割り当てない限り、このオーセンティケーターを使用しないでください。
* 自動的にプロンプトを表示せずにユーザーをリンクするファーストログインフローを構成するには、次の2つのオーセンティケーターを持つ新しいフローを作成します。
* **ユニークな場合にユーザーを作成**: このオーセンティケーターはKeycloakがユニークなユーザーを処理することを保証します。オーセンティケーターの要件を**代替**に設定します。
* **既存ユーザーを自動的に設定**: このオーセンティケーターは、検証なしで既存のユーザーを認証コンテキストに設定します。オーセンティケーターの要件を**代替**に設定します。
* この設定は最もシンプルな設定ですが、他のオーセンティケーターを使用することも可能です。例えば、*エンドユーザーにプロフィール情報を確認させたい場合は、フローの先頭に**プロフィール確認**オーセンティケーターを追加できます。*ユーザーに資格情報を検証させたい場合は、このフローに認証メカニズムを追加できます。認証メカニズムを追加すると、フローが複雑になります。例えば、**「既存ユーザーを自動的に設定」**と**「パスワードフォーム」**を**代替**サブフローで**必須**として設定できます。

#### ユーザー作成の自動化を無効にする

デフォルトのファーストログインフローは、外部IDに一致するKeycloakアカウントを検索し、リンクすることを提案します。一致するKeycloakアカウントが存在しない場合、フローは自動的にアカウントを作成します。

このデフォルトの動作は、一部の設定では適していない場合があります。一例として、すべてのユーザーが事前に作成されている読み取り専用LDAPユーザーストアを使用する場合があります。この場合、ユーザー作成の自動化をオフにする必要があります。

ユーザー作成を無効にする手順:

1. メニューの**認証**をクリックします。
2. リストから**最初のブローカーログイン**を選択します。
3. **ユニークな場合にユーザーを作成**を**無効**に設定します。
4. **既存アカウントのリンク確認**を**無効**に設定します。

この設定は、Keycloak自体が外部IDに対応する内部アカウントを特定できないことも意味します。そのため、**再認証による既存アカウントの確認**オーセンティケーターは、ユーザーにユーザー名とパスワードの両方を提供するように求めます。

IDPによるユーザー作成の有効化または無効化は、レルムの**ユーザー登録**スイッチとは完全に独立しています。IDPによるユーザー作成を有効にし、同時にレルムのログイン設定でユーザーによる自己登録を無効にすることができます。または、その逆も可能です。

#### 既存ユーザー検出によるファーストログインフロー

次のようなファーストログインフローを構成するには:

* このレルムにすでに登録されているユーザーのみがログインできる
* ユーザーはプロンプトなしに自動的にリンクされる

次の2つのオーセンティケーターを持つ新しいフローを作成します。

* **既存のブローカーユーザーの検出**: このオーセンティケーターは、ユニークなユーザーが処理されることを保証します。オーセンティケーターの要件を**必須**に設定します。
* **既存ユーザーを自動的に設定**: 検証なしで既存のユーザーを認証コンテキストに自動的に設定します。オーセンティケーターの要件を**必須**に設定します。

IDP構成の**ファーストログインフロー**をそのフローに設定する必要があります。IDP属性を使用してユーザープロフィール（苗字、名前など）を更新する場合は、**同期モード**を**強制**に設定することもできます。

このフローは、GitHubやFacebookなど、他のIDPへのアイデンティティ委任を行う場合に、ログインできるユーザーを管理したい場合に使用できます。

この設定では、Keycloakは外部IDに対応する内部アカウントを特定できません。**再認証による既存アカウントの確認**オーセンティケーターは、プロバイダーにユーザー名とパスワードを要求します。

#### 既存のブローカーリンクのオーバーライド

同じIDP内で同じKeycloakアカウントに別のアカウントをリンクする必要がある場合、次のオーセンティケーターを構成できます。

* **既存のリンクのオーバーライド確認**: このオーセンティケーターは、ユーザーの既存のブローカーリンクを検出し、既存のブローカーリンクのオーバーライドを確認するための確認ページを表示します。オーセンティケーターの要件を**必須**に設定します。

このオーセンティケーターの一般的な使用例を次に示します。

例として、メールアドレスが"john@gmail.com"のKeycloakユーザー"john"を考えます。そのユーザーは、"google"ユーザー名"john@gmail.com"でIDP"google"にリンクされています。

その後、Keycloakユーザー"john"は、メールアドレス"john-new@gmail.com"で新しいGoogleアカウントを作成します。

その後、Keycloakにログインする際に、ユーザーは"john-new@gmail.com"などの新しいユーザー名でIDP"google"で認証を行います。これはまだKeycloakアカウントにリンクされていません（Keycloakアカウント"john"はまだ"google"ユーザー"john@gmail.com"にリンクされているため）、そのため最初のブローカーログインフローがトリガーされます。

最初のブローカーログイン中に、Keycloakユーザー"john"は、何らかの方法で認証されます（デフォルトの最初のブローカーログイン再認証、または"既存のブローカーユーザーの検出"などのオーセンティケーターによる認証）。

このオーセンティケーターが認証フローにある場合、ユーザー"john"が確認した後、Keycloakユーザー"john"の"google"IDPへのリンクを、"google"ユーザー"john-new@gmail.com"への新しい"google"リンクでオーバーライドすることができます。

このオーセンティケーターを使用して認証フローを作成する際には、他のオーセンティケーター（再認証、または前述の"既存のブローカーユーザーの検出"の後）がKeycloakユーザーをすでに確立していることを確認してください。

### 外部IDPトークンの取得

Keycloakでは、IDPの設定ページの**トークンの保存**構成オプションを使用して、外部IDPからの認証プロセスからのトークンと応答を保存できます。

### アイデンティティ ブローカー ログアウト

Keycloakはログアウト時に、最初にログインに使用された外部IDプロバイダーにリクエストを送信し、そのIDプロバイダーからユーザーをログアウトします。


## 10. SSOプロトコルについて

このセクションでは、認証プロトコル、Keycloak 認証サーバー、および Keycloak 認証サーバーによって保護されたアプリケーションがこれらのプロトコルとどのようにやり取りするかについて説明します。

### OpenID Connect

OpenID Connect（OIDC）は、OAuth 2.0 の拡張機能である認証プロトコルです。

OAuth 2.0 は、承認プロトコルを構築するためのフレームワークであり、完全ではありません。一方、OIDC は、JSON Web Token（JWT）規格を使用する完全な認証および承認プロトコルです。JWT 規格は、アイデンティティトークンの JSON 形式と、データをコンパクトかつ Web フレンドリーな方法でデジタル署名および暗号化する手段を定義しています。

一般的に、OIDC は 2 つのユースケースを実装します。

最初のケースは、アプリケーションが Keycloak サーバーにユーザーの認証を要求することです。ログインが成功すると、アプリケーションはアイデンティティトークンとアクセストークンを受け取ります。アイデンティティトークンには、ユーザー名、メールアドレス、プロフィール情報などのユーザー情報が含まれています。アクセストークンは、ユーザーの役割マッピングなどのアクセス情報を含んでおり、アプリケーションがユーザーがアプリケーション内でアクセスできるリソースを判断するために使用されます。

2 番目のユースケースは、クライアントがリモートサービスにアクセスすることです。

クライアントは、ユーザーに代わってリモートサービスを呼び出すために、Keycloak からアクセストークンを要求します。

Keycloak はユーザーを認証し、ユーザーに要求元のクライアントへのアクセス許可を与えるかどうかを確認します。

クライアントは、レルムによってデジタル署名されたアクセストークンを受け取ります。

クライアントは、アクセストークンを使用してリモートサービスに対して REST リクエストを行います。

リモート REST サービスは、アクセストークンを抽出します。

リモート REST サービスは、トークンの署名を検証します。

リモート REST サービスは、トークン内のアクセス情報に基づいて、リクエストを処理するか拒否するかを決定します。

#### OIDC 認証フロー

OIDC には、クライアントまたはアプリケーションがユーザーを認証し、アイデンティティトークンとアクセストークンを取得するために使用できるいくつかの方法（フロー）があります。方法は、アクセスを要求しているアプリケーションまたはクライアントの種類によって異なります。

**認証コードフロー**

認証コードフローは、ブラウザベースのプロトコルであり、ブラウザベースのアプリケーションの認証と承認に適しています。アイデンティティトークンとアクセストークンを取得するためにブラウザのリダイレクトを使用します。

ユーザーは、ブラウザを使用してアプリケーションに接続します。アプリケーションは、ユーザーがアプリケーションにログインしていないことを検出します。

アプリケーションは、認証のためにブラウザを Keycloak にリダイレクトします。

アプリケーションは、ブラウザのリダイレクトでクエリパラメータとしてコールバックURLを渡します。Keycloak は、認証が成功するとこのパラメータを使用します。

Keycloak はユーザーを認証し、使い捨ての短命な一時コードを作成します。

Keycloak は、コールバックURLを使用してアプリケーションにリダイレクトし、一時コードをコールバックURLのクエリパラメータとして追加します。

アプリケーションは一時コードを抽出し、バックグラウンドで Keycloak に REST 呼び出しを行って、コードをアイデンティティトークン、アクセストークン、およびリフレッシュトークンと交換します。リプレイ攻撃を防ぐため、一時コードは 1 回しか使用できません。

システムは、そのトークンの有効期間中は盗まれたトークンに対して脆弱です。セキュリティとスケーラビリティの理由から、アクセストークンは通常、すぐに期限切れになるように設定されているため、その後のトークンリクエストは失敗します。トークンが期限切れになった場合、アプリケーションはログインプロトコルによって送信された追加のリフレッシュトークンを使用して、新しいアクセストークンを取得できます。

機密クライアントは、一時コードをトークンと交換するときにクライアントシークレットを提供します。公開クライアントは、クライアントシークレットを提供する必要はありません。公開クライアントは、HTTPS が厳密に実施され、クライアントに登録されたリダイレクトURIが厳密に制御されている場合に安全です。HTML5/JavaScript クライアントは、クライアントシークレットを HTML5/JavaScript クライアントに安全に送信する方法がないため、公開クライアントでなければなりません。詳細については、「クライアントの管理」の章を参照してください。

Keycloak は、Proof Key for Code Exchange 仕様もサポートしています。

**陰的フロー**

陰的フローは、ブラウザベースのプロトコルです。認証コードフローに似ていますが、リクエスト数が少なく、リフレッシュトークンはありません。

トークンがリダイレクトURI（以下を参照）を介して送信される場合、ブラウザの履歴にアクセストークンが漏洩する可能性があります。

また、このフローでは、クライアントにリフレッシュトークンが提供されません。そのため、アクセストークンは長期間有効にするか、期限切れになった場合はユーザーを再認証する必要があります。

このフローの使用はお勧めしません。このフローは、OIDC と OAuth 2.0 仕様に含まれているためサポートされています。

プロトコルは、次のとおりです。

ユーザーは、ブラウザを使用してアプリケーションに接続します。アプリケーションは、ユーザーがアプリケーションにログインしていないことを検出します。

アプリケーションは、認証のためにブラウザを Keycloak にリダイレクトします。

アプリケーションは、ブラウザのリダイレクトでクエリパラメータとしてコールバックURLを渡します。Keycloak は、認証が成功するとこのパラメータを使用します。

Keycloak はユーザーを認証し、アイデンティティトークンとアクセストークンを作成します。Keycloak は、コールバックURLを使用してアプリケーションにリダイレクトし、さらにアイデンティティトークンとアクセストークンをコールバックURLのクエリパラメータとして追加します。

アプリケーションは、コールバックURLからアイデンティティトークンとアクセストークンを抽出します。

**リソースオーナーパスワード認証付与（ダイレクトアクセス付与）**

ダイレクトアクセス付与は、REST クライアントがユーザーに代わってトークンを取得するために使用されます。ユーザーの資格情報を含む HTTP POST リクエストです。

* ユーザーの資格情報。資格情報は、フォームパラメータ内で送信されます。
* クライアントの ID。
* クライアントシークレット（機密クライアントの場合）。

HTTP レスポンスには、アイデンティティトークン、アクセストークン、およびリフレッシュトークンが含まれています。

**クライアント認証付与**

クライアント認証付与は、外部ユーザーに代わって機能するトークンを取得するのではなく、クライアントに関連付けられたサービスアカウントのメタデータと権限に基づいてトークンを作成します。クライアント認証付与は、REST クライアントによって使用されます。

詳細については、「サービスアカウント」の章を参照してください。

**リフレッシュトークン付与**

デフォルトでは、Keycloak はほとんどのフローのトークンレスポンスでリフレッシュトークンを返します。上記で説明した陰的フローまたはクライアント認証付与は、例外です。

リフレッシュトークンは、SSO ブラウザセッションのユーザーセッションに関連付けられており、ユーザーセッションの有効期間中は有効な場合があります。ただし、クライアントは指定された間隔で少なくとも 1 回はリフレッシュトークンリクエストを送信する必要があります。そうしないと、セッションは「アイドル状態」と見なされ、期限切れになる可能性があります。詳細については、「タイムアウト」セクションを参照してください。

Keycloak は、オフライントークンをサポートしています。オフライントークンは、クライアントが対応するブラウザ SSO セッションがすでに期限切れになっている場合でも、リフレッシュトークンを使用する必要がある場合に通常使用されます。

リフレッシュトークンのローテーション

リフレッシュトークンが使用されたら無効になるように指定することができます。これは、クライアントは、Keycloak によって無効になる可能性のある古いリフレッシュトークンが使用されなくなるため、常に最後のリフレッシュレスポンスからのリフレッシュトークンを保存する必要があることを意味します。これは、「タイムアウト」セクションで指定されている「リフレッシュトークンの無効化」オプションを使用して設定できます。

Keycloak は、リフレッシュトークンのローテーションが存在しない状況もサポートしています。この場合、リフレッシュトークンはログイン中に返されますが、リフレッシュトークンリクエストからのその後のレスポンスでは、新しいリフレッシュトークンは返されません。この方法は、たとえば、FAPI 2 ドラフト仕様で推奨されています。Keycloak では、クライアントポリシーを使用して、リフレッシュトークンのローテーションをスキップすることができます。クライアントプロファイルに「suppress-refresh-token-rotation」エグゼキュータを追加し、クライアントポリシーを構成して、どのクライアントに対してプロファイルがトリガーされるかを指定できます。これは、これらのクライアントの場合、リフレッシュトークンのローテーションがスキップされることを意味します。

**デバイス認証付与**

これは、入力機能が限られているか、適切なブラウザがない、インターネット接続されたデバイスで実行されているクライアントによって使用されます。プロトコルの簡単な概要を以下に示します。

アプリケーションは、Keycloak にデバイスコードとユーザーコードを要求します。Keycloak は、デバイスコードとユーザーコードを作成します。Keycloak は、アプリケーションにデバイスコードとユーザーコードを含むレスポンスを返します。

アプリケーションは、ユーザーにユーザーコードと検証URIを提供します。ユーザーは、別のブラウザを使用して認証するために検証URIにアクセスします。Keycloak 検証URI（/realms/realm_name/device）にリダイレクトされる短い verification_uri を、Keycloak の外部、たとえばプロキシで定義できます。

アプリケーションは、ユーザーがユーザー認証を完了したかどうかを調べるために、繰り返し Keycloak をポーリングします。ユーザー認証が完了すると、アプリケーションはデバイスコードを交換して、アイデンティティトークン、アクセストークン、およびリフレッシュトークンを取得します。

**クライアント開始バックチャネル認証付与**

この機能は、OAuth 2.0 の認証コード付与のように、ユーザーのブラウザを通じてリダイレクトすることなく、OpenID プロバイダーと直接通信することによって、認証フローを開始したいクライアントによって使用されます。プロトコルの簡単な概要を以下に示します。

クライアントは、クライアントによって行われた認証リクエストを識別する auth_req_id を Keycloak に要求します。Keycloak は、auth_req_id を作成します。

この auth_req_id を受け取ると、このクライアントは、ユーザーが認証されるまで、Keycloak を繰り返しポーリングして、auth_req_id と引き換えに Keycloak からアクセストークン、リフレッシュトークン、および ID トークンを取得する必要があります。

管理者は、レルムごとに CIBA ポリシーとして、クライアント開始バックチャネル認証（CIBA）関連の操作を構成できます。

また、Keycloak ドキュメントの「アプリケーションとサービスの保護ガイド」の「バックチャネル認証エンドポイント」セクションと、「アプリケーションとサービスの保護ガイド」の「クライアント開始バックチャネル認証付与」セクションも参照してください。

**CIBA ポリシー**

管理者は、管理コンソールで次の操作を実行します。

* 「認証」→「CIBA ポリシー」タブを開きます。
* アイテムを構成して、「保存」をクリックします。

構成可能なアイテムとその説明を以下に示します。

| 構成 | 説明 |
|---|---|
| バックチャネルトークン配信モード | CD（消費デバイス）が認証結果と関連するトークンを取得する方法を指定します。「poll」、「ping」、「push」の 3 つのモードがあります。Keycloak は「poll」のみをサポートします。デフォルト設定は「poll」です。この構成は必須です。詳細については、CIBA 仕様を参照してください。 |
| 有効期限 | 認証リクエストが受信されてから、auth_req_id の有効期限（秒単位）。デフォルト設定は 120 です。この構成は必須です。詳細については、CIBA 仕様を参照してください。 |
| 間隔 | CD（消費デバイス）がトークンエンドポイントへのポーリングリクエストの間に待機する必要がある間隔（秒単位）。デフォルト設定は 5 です。この構成はオプションです。詳細については、CIBA 仕様を参照してください。 |
| 認証要求ユーザーヒント | 認証が要求されているエンドユーザーを識別する方法。デフォルト設定は「login_hint」です。「login_hint」、「login_hint_token」、「id_token_hint」の 3 つのモードがあります。Keycloak は「login_hint」のみをサポートします。この構成は必須です。詳細については、CIBA 仕様を参照してください。 |

**プロバイダー設定**

CIBA 付与は、次の 2 つのプロバイダーを使用します。

* 認証チャネルプロバイダー：Keycloak と、AD（認証デバイス）を介してユーザーを実際に認証するエンティティ間の通信を提供します。
* ユーザーレゾルバープロバイダー：クライアントによって提供された情報から Keycloak の UserModel を取得して、ユーザーを識別します。

Keycloak には、デフォルトのプロバイダーが両方ともあります。ただし、管理者は、次のいずれかのように、認証チャネルプロバイダーを設定する必要があります。

```
kc.[sh|bat] start --spi-ciba-auth-channel-ciba-http-auth-channel-http-authentication-channel-uri=https://backend.internal.example.com
```

構成可能なアイテムとその説明を以下に示します。

| 構成 | 説明 |
|---|---|
| http-authentication-channel-uri | AD（認証デバイス）を介してユーザーを実際に認証するエンティティの URI を指定します。 |

**認証チャネルプロバイダー**

CIBA 標準ドキュメントでは、AD によってユーザーを認証する方法が指定されていません。そのため、製品の裁量で実装される場合があります。Keycloak は、この認証を外部認証エンティティに委任します。認証エンティティとの通信のために、Keycloak は認証チャネルプロバイダーを提供します。

Keycloak の実装では、認証エンティティが Keycloak の管理者の制御下にあると仮定されているため、Keycloak は認証エンティティを信頼しています。Keycloak の管理者が制御できない認証エンティティを使用することはお勧めしません。

認証チャネルプロバイダーは、SPI プロバイダーとして提供されるため、Keycloak のユーザーは、独自の環境に合わせて独自のプロバイダーを実装できます。Keycloak は、HTTP を使用して認証エンティティと通信する、HTTP 認証チャネルプロバイダーと呼ばれるデフォルトのプロバイダーを提供します。

Keycloak のユーザーが HTTP 認証チャネルプロバイダーを使用したい場合は、Keycloak と認証エンティティ間の次の 2 つの部分からなる契約を知る必要があります。

* 認証委任リクエスト/レスポンス
* 認証結果通知/ACK

**認証委任リクエスト/レスポンス**

Keycloak は、認証リクエストを認証エンティティに送信して、AD によってユーザーを認証するよう要求します。

```
POST [delegation_reception]
```

| ヘッダー | 値 | 説明 |
|---|---|---|
| Content-Type | application/json | メッセージ本文は JSON 形式です。 |
| Authorization | Bearer [token] | [token] は、認証エンティティが認証結果を Keycloak に通知する場合に使用されます。 |

| パラメータ | タイプ | 説明 |
|---|---|---|
| delegation_reception | パス | 認証エンティティによって提供される、委任リクエストを受け取るためのエンドポイント |

| 本文 | 説明 |
|---|---|
| login_hint | 認証エンティティに、AD によって認証されるユーザーを伝えます。デフォルトでは、ユーザーの「username」です。このフィールドは必須であり、CIBA 標準ドキュメントで定義されています。 |
| scope | 認証エンティティが認証されたユーザーから同意を得る必要があるスコープを伝えます。このフィールドは必須であり、CIBA 標準ドキュメントで定義されています。 |
| is_consent_required | 認証エンティティがスコープについて認証されたユーザーから同意を得る必要があるかどうかを示します。このフィールドは必須です。 |
| binding_message | 値は、CD と AD の両方の UI に表示され、AD による認証が CD によってトリガーされたことをユーザーに認識させるために使用されます。このフィールドはオプションであり、CIBA 標準ドキュメントで定義されています。 |
| acr_values | CD から要求された認証コンテキストクラス参照を伝えます。このフィールドはオプションであり、CIBA 標準ドキュメントで定義されています。 |

認証エンティティは、Keycloak に対して、Keycloak から認証リクエストを受け取ったことを通知するために、レスポンスを返します。

| HTTP ステータスコード | 説明 |
|---|---|
| 201 | Keycloak に、認証委任リクエストを受け取ったことを通知します。 |

**認証結果通知/ACK**

認証エンティティは、認証リクエストの結果を Keycloak に送信します。

```
POST /realms/[realm]/protocol/openid-connect/ext/ciba/auth/callback
```

| ヘッダー | 値 | 説明 |
|---|---|---|
| Content-Type | application/json | メッセージ本文は JSON 形式です。 |
| Authorization | Bearer [token] | [token] は、認証エンティティが認証委任リクエストで Keycloak から受け取ったものと一致する必要があります。 |

| パラメータ | タイプ | 説明 |
|---|---|---|
| realm | パス | レルム名 |

| 本文 | 説明 |
|---|---|
| status | AD によるユーザー認証の結果を伝えます。次のいずれかのステータスである必要があります。
* SUCCEED：AD による認証が正常に完了しました。
* UNAUTHORIZED：AD による認証が完了していません。
* CANCELLED：AD による認証はユーザーによってキャンセルされました。 |

Keycloak は、認証エンティティに対して、Keycloak が認証エンティティから AD によるユーザー認証の結果を受け取ったことを通知するために、レスポンスを返します。

| HTTP ステータスコード | 説明 |
|---|---|
| 200 | 認証エンティティに、認証結果の通知を受け取ったことを通知します。 |

**ユーザーレゾルバープロバイダー**

同じユーザーでも、CD、Keycloak、および認証エンティティでそれぞれ異なる表現になる場合があります。

CD、Keycloak、および認証エンティティが同じユーザーを認識するため、このユーザーレゾルバープロバイダーは、これらの間で独自のユーザー表現を変換します。

ユーザーレゾルバープロバイダーは、SPI プロバイダーとして提供されるため、Keycloak のユーザーは、独自の環境に合わせて独自のプロバイダーを実装できます。Keycloak は、次の特性を持つ、Default User Resolver Provider と呼ばれるデフォルトのプロバイダーを提供します。

* login_hint パラメータのみをサポートし、デフォルトとして使用されます。
* Keycloak の UserModel の username は、CD、Keycloak、および認証エンティティでユーザーを表すために使用されます。

#### OIDC ログアウト

OIDC には、ログアウトメカニズムに関連する 4 つの仕様があります。

* セッション管理
* RP 開始ログアウト
* フロントチャネルログアウト
* バックチャネルログアウト

これらすべては OIDC 仕様で説明されているため、ここでは簡単な概要のみを示します。

**セッション管理**

これは、ブラウザベースのログアウトです。アプリケーションは、Keycloak から定期的にセッションステータス情報を取得します。Keycloak でセッションが終了すると、アプリケーションはそれを認識して独自のログアウトをトリガーします。

**RP 開始ログアウト**

これもブラウザベースのログアウトであり、ユーザーを Keycloak の特定のエンドポイントにリダイレクトすることでログアウトが開始されます。このリダイレクトは、ユーザーが以前に Keycloak を使用して認証されたアプリケーションのページの「ログアウト」リンクをクリックした場合に発生します。

ユーザーがログアウトエンドポイントにリダイレクトされると、Keycloak はクライアントにログアウトリクエストを送信して、クライアント側のローカルユーザーセッションを無効にし、ログアウトプロセスが完了したら、ユーザーを特定の URL にリダイレクトします。id_token_hint パラメータが使用されていない場合は、ユーザーにログアウトを確認するように要求される場合があります。ログアウト後、ユーザーは、パラメータとして提供されている限り、指定された post_logout_redirect_uri に自動的にリダイレクトされます。post_logout_redirect_uri を含める場合、client_id または id_token_hint パラメータのいずれかを含める必要があります。また、post_logout_redirect_uri パラメータは、クライアント構成で指定されている「有効なポストログアウトリダイレクトURI」のいずれかと一致する必要があります。

クライアント構成によっては、ログアウトリクエストはフロントチャネルまたはバックチャネルを介してクライアントに送信されます。前のセクションで説明したセッション管理に依存するフロントエンドブラウザクライアントの場合、Keycloak はログアウトリクエストを送信する必要はありません。これらのクライアントは、ブラウザの SSO セッションがログアウトされたことを自動的に検出します。

**フロントチャネルログアウト**

クライアントがフロントチャネルを介してログアウトリクエストを受信するように構成するには、「フロントチャネルログアウト」クライアント設定を参照してください。この方法を使用する場合、次の点を考慮してください。

* Keycloak からクライアントに送信されるログアウトリクエストは、ブラウザと、ログアウトページ用にレンダリングされる埋め込み iframe に依存します。
* iframe に基づいているため、フロントチャネルログアウトは、コンテンツセキュリティポリシー（CSP）の影響を受ける可能性があり、ログアウトリクエストがブロックされる可能性があります。
* ユーザーがログアウトページをレンダリングする前に、またはログアウトリクエストが実際にクライアントに送信される前にブラウザを閉じると、クライアントのセッションは無効にならない可能性があります。
* ユーザーをログアウトし、クライアントのセッションを終了する、より信頼性の高い安全な方法として、バックチャネルログアウトの使用を検討してください。
* クライアントがフロントチャネルログアウトで有効になっていない場合、Keycloak は最初に「バックチャネルログアウトURL」を使用して、バックチャネルを介してログアウトリクエストを送信しようとします。定義されていない場合は、サーバーは「管理者URL」の使用にフォールバックします。

**バックチャネルログアウト**

これは、ブラウザに依存しないログアウトであり、Keycloak とクライアント間の直接的なバックチャネル通信を使用します。Keycloak は、ログアウトトークンを含む HTTP POST リクエストを、Keycloak にログインしているすべてのクライアントに送信します。これらのリクエストは、Keycloak の登録されたバックチャネルログアウトURLに送信され、クライアント側でログアウトをトリガーする必要があります。

#### Keycloak サーバー OIDC URI エンドポイント

Keycloak は、次の OIDC エンドポイントを公開します。これらのエンドポイントは、Keycloak 以外のクライアントアダプタが OIDC を使用して認証サーバーと通信する場合に使用できます。これらはすべて相対URLです。URL のルートは、HTTP(S) プロトコル、ホスト名、およびオプションでパスで構成されます。たとえば、

```
https://localhost:8080
```

* **`/realms/{realm-name}/protocol/openid-connect/auth`**
* 認証コードフローで一時コードを取得したり、陰的フロー、ダイレクト付与、またはクライアント付与を使用してトークンを取得するために使用されます。
* **`/realms/{realm-name}/protocol/openid-connect/token`**
* 認証コードフローで一時コードをトークンに変換するために使用されます。
* **`/realms/{realm-name}/protocol/openid-connect/logout`**
* ログアウトを実行するために使用されます。
* **`/realms/{realm-name}/protocol/openid-connect/userinfo`**
* OIDC 仕様で説明されているユーザー情報サービスに使用されます。
* **`/realms/{realm-name}/protocol/openid-connect/revoke`**
* RFC7009 で説明されている OAuth 2.0 トークン無効化に使用されます。
* **`/realms/{realm-name}/protocol/openid-connect/certs`**
* JSON Web Token（jwks_uri）を検証するために使用される公開鍵を含む JSON Web キーセット（JWKS）に使用されます。
* **`/realms/{realm-name}/protocol/openid-connect/auth/device`**
* デバイスコードとユーザーコードを取得するためのデバイス認証付与に使用されます。
* **`/realms/{realm-name}/protocol/openid-connect/ext/ciba/auth`**
* クライアント開始バックチャネル認証付与で、クライアントによって行われた認証リクエストを識別する auth_req_id を取得するための URL エンドポイントです。
* **`/realms/{realm-name}/protocol/openid-connect/logout/backchannel-logout`**
* OIDC 仕様で説明されているバックチャネルログアウトを実行するための URL エンドポイントです。

これらのすべてで、{realm-name} をレルムの名前に置き換えてください。

### SAML

SAML 2.0 は、OIDC と同様の仕様ですが、より成熟しています。SOAP と Web サービスメッセージング仕様から派生しているため、一般的に OIDC よりも冗長です。SAML 2.0 は、認証サーバーとアプリケーション間で XML ドキュメントを交換する認証プロトコルです。XML 署名と暗号化は、リクエストとレスポンスを検証するために使用されます。

一般的に、SAML は 2 つのユースケースを実装します。

最初のユースケースは、アプリケーションが Keycloak サーバーにユーザーの認証を要求することです。ログインが成功すると、アプリケーションは XML ドキュメントを受け取ります。このドキュメントには、ユーザー属性を指定する SAML アサーションが含まれています。レルムは、ユーザーの役割マッピングなどのアクセス情報を含んだドキュメントにデジタル署名し、アプリケーションがユーザーがアプリケーション内でアクセスできるリソースを判断するために使用されます。

2 番目のユースケースは、クライアントがリモートサービスにアクセスすることです。クライアントは、ユーザーに代わってリモートサービスを呼び出すために、Keycloak から SAML アサーションを要求します。

#### SAML バインディング

Keycloak は、3 つのバインディングタイプをサポートしています。

##### リダイレクトバインディング

リダイレクトバインディングは、一連のブラウザリダイレクトURIを使用して情報を交換します。

ユーザーは、ブラウザを使用してアプリケーションに接続します。アプリケーションは、ユーザーが認証されていないことを検出します。

アプリケーションは、XML 認証リクエストドキュメントを生成し、URI のクエリパラメータとしてエンコードします。URI は、Keycloak サーバーへのリダイレクトに使用されます。設定によっては、アプリケーションは XML ドキュメントにデジタル署名し、署名を Keycloak へのリダイレクトURIのクエリパラメータとして含めることもできます。この署名は、リクエストを送信するクライアントを検証するために使用されます。

ブラウザは Keycloak にリダイレクトされます。

サーバーは、XML 認証リクエストドキュメントを抽出し、必要に応じてデジタル署名を検証します。

ユーザーは、認証資格情報を入力します。

認証後、サーバーは XML 認証レスポンスドキュメントを生成します。ドキュメントには、名前、住所、メールアドレス、およびユーザーが持つ役割マッピングなどのユーザーに関するメタデータを含む SAML アサーションが含まれています。ドキュメントは通常、XML 署名を使用してデジタル署名され、暗号化されることもあります。

XML 認証レスポンスドキュメントは、リダイレクトURIのクエリパラメータとしてエンコードされます。URI は、ブラウザをアプリケーションに戻します。デジタル署名もクエリパラメータとして含まれます。

アプリケーションは、リダイレクトURIを受け取り、XML ドキュメントを抽出します。

アプリケーションは、レルムの署名を検証して、有効な認証レスポンスを受信していることを確認します。SAML アサーション内の情報は、アクセス決定を行うか、ユーザーデータを表示するために使用されます。

##### POST バインディング

POST バインディングは、リダイレクトバインディングに似ていますが、POST バインディングは、GET リクエストを使用するのではなく、POST リクエストを使用して XML ドキュメントを交換します。POST バインディングは、JavaScript を使用して、ブラウザがドキュメントを交換するときに Keycloak サーバーまたはアプリケーションに POST リクエストを送信します。HTTP は、埋め込み JavaScript を含む HTML フォームを含む HTML ドキュメントで応答します。ページがロードされると、JavaScript は自動的にフォームを呼び出します。

POST バインディングは、次の 2 つの制限により推奨されます。

* セキュリティ：リダイレクトバインディングでは、SAML レスポンスは URL の一部です。レスポンスをログでキャプチャできるため、それほど安全ではありません。
* サイズ：HTTP ペイロードでドキュメントを送信すると、限られた URL よりも大量のデータを送信できます。

##### ECP

Enhanced Client or Proxy（ECP）は、Web ブラウザのコンテキスト外で SAML 属性を交換できる SAML v.2.0 プロファイルです。REST または SOAP ベースのクライアントでよく使用されます。

#### Keycloak サーバー SAML URI エンドポイント

Keycloak には、すべての SAML リクエスト用のエンドポイントが 1 つあります。

```
http(s)://authserver.host/realms/{realm-name}/protocol/saml
```

すべてのバインディングはこのエンドポイントを使用します。

### OpenID Connect と SAML の比較

プロトコルを選択する際に考慮すべき要因を以下に示します。

ほとんどの場合、Keycloak は OIDC を使用することを推奨します。

#### OIDC

* OIDC は、Web と連携するように特別に設計されています。
* OIDC は、SAML よりもクライアント側で実装が容易なため、HTML5/JavaScript アプリケーションに適しています。
* OIDC トークンは JSON 形式であるため、Javascript で簡単に消費できます。
* OIDC には、セキュリティの実装を容易にする機能があります。たとえば、仕様がユーザーのログインステータスを判断するために使用する「iframe トリック」を参照してください。

#### SAML

* SAML は、Web の上に動作するレイヤーとして設計されています。
* SAML は、OIDC よりも冗長になる可能性があります。
* ユーザーは、成熟しているという認識から、OIDC よりも SAML を選択します。
* ユーザーは、SAML で保護されている既存のアプリケーションのために、OIDC よりも SAML を選択します。

### Dockerレジストリ v2 認証について

Dockerレジストリ v2 認証は、Dockerレジストリに対してユーザーを認証するプロトコルです。これは、OpenID Connect (OIDC) と似た仕組みで動作します。

Keycloakは、このプロトコルを実装しており、DockerクライアントがKeycloak認証サーバーを使用してレジストリに対して認証することを可能にします。このプロトコルは、標準的なトークンと署名メカニズムを使用しますが、真のOIDC実装とは異なります。

具体的には、リクエストとレスポンスに非常に特定のJSON形式を使用し、リポジトリ名と権限をOAuthスコープメカニズムにマッピングするという点で異なります。

> ★★★★★★★★★★★★★★★
Dockerレジストリ v2 認証については利用しないため、詳細は割愛
★★★★★★★★★★★★★★★

## 11. Keycloak 管理コンソールのアクセス制御

Keycloak で作成された各レルムには、そのレルムを管理するための専用の管理コンソールがあります。**マスターレルム**は特別なレルムで、管理者はシステム上の複数のレルムを管理できます。また、サーバーを管理するために、異なるレルムのユーザーに細かいアクセス権を定義することもできます。この章では、これらのシナリオについて詳しく説明します。

### マスターレルムのアクセス制御

Keycloak のマスターレルムは特別なレルムであり、他のレルムとは異なる扱いをされます。Keycloak マスターレルムのユーザーには、Keycloak サーバーにデプロイされている 0 個以上のレルムを管理する権限を付与できます。レルムが作成されると、Keycloak はその新しいレルムにアクセスするための細かい権限を付与するさまざまな役割を自動的に作成します。管理コンソールと管理 REST エンドポイントへのアクセスは、これらの役割をマスターレルムのユーザーにマッピングすることで制御できます。複数のスーパーユーザーを作成することも、特定のレルムのみを管理できるユーザーを作成することも可能です。

#### グローバル役割

マスターレルムには、レルムレベルの役割が 2 つあります。

- **admin**: スーパーユーザーで、サーバー上のすべてのレルムを管理する完全なアクセス権を持ちます。
- **create-realm**: 新しいレルムを作成できます。作成した新しいレルムには、すべてアクセス権が付与されます。

#### レルム固有の役割

マスターレルム内の管理ユーザーには、システム内の 1 つ以上の他のレルムの管理権限を付与できます。Keycloak の各レルムは、マスターレルムのクライアントで表されます。クライアントの名前は `<レルム名>-realm` です。これらのクライアントはそれぞれ、個々のレルムを管理するためのさまざまなレベルのアクセスを定義する、クライアントレベルの役割が定義されています。

利用可能な役割は以下のとおりです。

- **view-realm**: レルムの情報を表示できます。
- **view-users**: レルム内のユーザー情報を表示できます。
- **view-clients**: レルム内のクライアント情報を表示できます。
- **view-events**: レルム内のイベントログを表示できます。
- **manage-realm**: レルムの構成を管理できます。
- **manage-users**: レルム内のユーザーを管理できます。
- **create-client**: レルムに新しいクライアントを作成できます。
- **manage-clients**: レルム内のクライアントを管理できます。
- **manage-events**: レルム内のイベントログを管理できます。
- **view-identity-providers**: アイデンティティプロバイダーを表示できます。
- **manage-identity-providers**: アイデンティティプロバイダーを管理できます。
- **impersonation**: レルム内の他のユーザーになりすますことができます。

必要な役割をユーザーに割り当てると、ユーザーは管理コンソールの特定の部分のみを使用できるようになります。

`manage-users` 役割を持つ管理者は、自分自身に割り当てられたユーザーのみに管理者役割を割り当てることができます。つまり、管理者が `manage-users` 役割を持っているが `manage-realm` 役割を持っていない場合、この役割を割り当てることはできません。

### 専用のレルム管理コンソール

各レルムには、URL `admin/{realm-name}/console` からアクセスできる専用の管理コンソールがあります。そのレルム内のユーザーには、特定のユーザー役割マッピングを割り当てることで、レルム管理権限を付与できます。

各レルムには、`realm-management` という組み込みのクライアントがあります。これは、レルムの左メニュー項目の `クライアント` から確認できます。このクライアントは、レルムの管理を許可できる権限を指定するクライアントレベルの役割を定義しています。

- **view-realm**: レルムの情報を表示できます。
- **view-users**: レルム内のユーザー情報を表示できます。
- **view-clients**: レルム内のクライアント情報を表示できます。
- **view-events**: レルム内のイベントログを表示できます。
- **manage-realm**: レルムの構成を管理できます。
- **manage-users**: レルム内のユーザーを管理できます。
- **create-client**: レルムに新しいクライアントを作成できます。
- **manage-clients**: レルム内のクライアントを管理できます。
- **manage-events**: レルム内のイベントログを管理できます。
- **view-identity-providers**: アイデンティティプロバイダーを表示できます。
- **manage-identity-providers**: アイデンティティプロバイダーを管理できます。
- **impersonation**: レルム内の他のユーザーになりすますことができます。

必要な役割をユーザーに割り当てると、ユーザーは管理コンソールの特定の部分のみを使用できるようになります。

### 詳細な管理権限

**詳細な管理権限**は、**プレビュー機能**であり、完全にはサポートされていません。この機能はデフォルトで無効になっています。

有効にするには、サーバーを `--features=preview` または `--features=admin-fine-grained-authz` オプションで起動します。

`manage-realm` や `manage-users` のような役割は、粒度が粗すぎる場合があります。より細かい権限を持つ、制限された管理アカウントを作成したい場合があります。Keycloak では、レルムの管理に対する制限されたアクセスポリシーを定義して割り当てることができます。たとえば、以下のようなことができます。

- 特定のクライアントの管理
- 特定のグループに所属するユーザーの管理
- グループのメンバーシップの管理
- 制限されたユーザー管理
- 詳細ななりすまし制御
- ユーザーに特定の制限された役割セットを割り当てる
- コンポジット役割に特定の制限された役割セットを割り当てる
- クライアントのスコープに特定の制限された役割セットを割り当てる
- ユーザー、グループ、役割、クライアントの表示と管理のための新しい一般的なポリシー

詳細な管理権限について注意すべき点がいくつかあります。

- 詳細な管理権限は、**認可サービス**の上に実装されています。詳細な管理権限を利用する前に、認可サービスについてよく理解することをお勧めします。
- 詳細な権限は、**専用の管理コンソール**内でのみ利用でき、それらのレルム内で定義された管理者のみが利用できます。レルム間の詳細な権限を定義することはできません。
- 詳細な権限は、追加の権限を付与するために使用されます。組み込みの管理者役割のデフォルトの動作をオーバーライドすることはできません。

#### 特定のクライアントの管理

最初に、管理者が 1 つのクライアントのみを管理できるようにする方法を見てみましょう。この例では、`test` というレルムと `sales-application` というクライアントがあるとします。`test` レルムで、そのレルムのユーザーに、そのアプリケーションのみを管理する権限を付与します。

レルム間の詳細な権限は定義できません。マスターレルムの管理者は、前の章で定義されている事前定義された管理者役割に制限されます。

##### 権限設定

最初に、管理コンソールにログインして、そのクライアントの権限を設定する必要があります。管理するクライアントの管理セクションに移動します。

**クライアント管理**

**クライアント権限タブ**

デフォルトでは、各クライアントは詳細な権限を有効にすることはできません。そのため、権限を初期化するには、**権限を有効にする**スイッチをオンにします。

**権限を有効にする**スイッチをオフにすると、このクライアントに対して定義したすべての権限が削除されます。

**クライアント権限タブ**

**権限を有効にする**をオンにすると、認可サービスを使用して、さまざまな権限オブジェクトが舞台裏で初期化されます。この例では、クライアントの `manage` 権限に興味があります。これをクリックすると、クライアントの `manage` 権限を処理する権限にリダイレクトされます。すべての認可オブジェクトは、`realm-management` クライアントの `認可` タブに含まれています。

**クライアント管理権限**

初期化されたばかりの `manage` 権限には、関連付けられているポリシーがありません。ポリシータブに移動して、ポリシーを作成する必要があります。早く行くために、上の画像の `認可` リンクをクリックし、ポリシータブをクリックします。

このページには、`ポリシーの作成` というプルダウンメニューがあります。定義できるポリシーは多数あります。役割やグループに関連付けられたポリシーを定義することも、JavaScript でルールを定義することもできます。この簡単な例では、**ユーザーポリシー**を作成します。

**ユーザーポリシー**

このポリシーは、ユーザーデータベース内のハードコーディングされたユーザーと一致します。この場合は、`sales-admin` ユーザーです。次に、`sales-application` クライアントの `manage` 権限ページに戻り、ポリシーを権限オブジェクトに割り当てる必要があります。

**ユーザーポリシーの割り当て**

これで、`sales-admin` ユーザーは `sales-application` クライアントを管理する権限を持つようになりました。

もう 1 つ行う必要があることがあります。`役割マッピング` タブに移動し、`sales-admin` に `query-clients` 役割を割り当てます。

**query-clients の割り当て**

なぜこれをしなければならないのでしょうか？この役割は、`sales-admin` が管理コンソールにアクセスしたときに、管理コンソールにどのメニュー項目を表示するかを指示します。`query-clients` 役割は、管理コンソールに `sales-admin` ユーザーに対してクライアントメニューを表示するように指示します。

**重要:** `query-clients` 役割を設定しないと、`sales-admin` などの制限された管理者は、管理コンソールにログインしても、メニューオプションが表示されません。

##### テスト

次に、マスターレルムからログアウトし、`sales-admin` をユーザー名として、`test` レルムの**専用の管理コンソール**に再ログインします。これは、`admin/test/console` にあります。

**Sales admin ログイン**

これで、この管理者は 1 つのクライアントを管理できるようになりました。

#### ユーザー役割マッピングの制限

もう 1 つ行いたいこととして、管理者がユーザーに割り当てることができる役割セットを制限できます。前の例を続行して、`sales-admin` ユーザーの権限セットを拡張し、このアプリケーションにアクセスできるユーザーを制御できるようにします。詳細な権限を使用することで、`sales-admin` が `sales-application` に特定のアクセス権を付与する役割のみを割り当てることができるようにできます。また、管理者が役割をマッピングすることだけを許可し、他の種類のユーザー管理は行えないように制限することもできます。

`sales-application` は、3 つの異なるクライアント役割を定義しています。

**Sales application の役割**

`sales-admin` ユーザーがシステム内のすべてのユーザーにこれらの役割をマッピングできるようにします。そのためには、最初に管理者が役割をマッピングできるようにする必要があります。`viewLeads` 役割をクリックすると、この役割には `権限` タブがあることがわかります。

**View leads 役割の権限タブ**

このタブをクリックして **権限を有効にする** をオンにすると、ポリシーを適用できるアクションがいくつか表示されます。

**View leads 権限**

私たちが興味を持っているのは `map-role` です。この権限をクリックし、前の例で作成したのと同じユーザーポリシーを追加します。

**Map-roles 権限**

これにより、`sales-admin` は `viewLeads` 役割をマッピングできるようになりました。ただし、管理者がこの役割をマッピングできるユーザーを指定していません。そのためには、このレルムの管理コンソールの `ユーザー` セクションに移動する必要があります。左メニュー項目の `ユーザー` をクリックすると、レルムのユーザーインターフェースが表示されます。`権限` タブが表示されるはずです。これをクリックして有効にします。

**ユーザー権限**

私たちが興味を持っている権限は `map-roles` です。これは、管理者がユーザーに役割をマッピングすることのみを許可する制限的なポリシーです。`map-roles` 権限をクリックして、再びこのために作成したユーザーポリシーを追加すると、`sales-admin` はすべてのユーザーに役割をマッピングできるようになります。

最後に、`sales-admin` に `view-users` 役割を追加する必要があります。これにより、管理者は、`sales-application` の役割を追加したいレルム内のユーザーを表示できるようになります。

**view-users の追加**

テストする

次に、マスターレルムからログアウトし、`sales-admin` をユーザー名として、`test` レルムの**専用の管理コンソール**に再ログインします。これは、`admin/test/console` にあります。

これで、`sales-admin` はシステム内のユーザーを表示できるようになります。ユーザーのいずれかを選択すると、`役割マッピング` タブを除いて、各ユーザー詳細ページは読み取り専用になります。このタブに移動すると、`sales-application` の役割を参照した場合を除いて、管理者がユーザーにマッピングできる `使用可能` な役割はありません。

**viewLeads の割り当て**

`sales-admin` は `viewLeads` 役割のみをマッピングできることを指定しました。

クライアントごとの map-roles ショートカット

`sales-application` が公開したすべてのクライアント役割に対してこれを行うのは面倒です。作業を簡単にするために、管理者がクライアントによって定義されたすべての役割をマッピングできることを指定する方法があります。マスターレルム管理者の管理コンソールに再ログインし、`sales-application` の権限ページに戻ると、`map-roles` 権限が表示されます。

**クライアント map-roles 権限**

この特定の権限に管理者にアクセス権を付与すると、その管理者はクライアントによって定義されたすべての役割をマッピングできるようになります。

#### 権限の完全なリスト

詳細な権限を使用すると、特定のクライアントやクライアントの特定の役割の管理以外にも、さまざまなことができます。この章では、レルムに対して記述できるすべての権限タイプのリストを定義しています。

##### 役割

特定の役割の `権限` タブに移動すると、次の権限タイプが表示されます。

- **map-role**: 管理者がこの役割をユーザーにマッピングできるかどうかを決定するポリシー。これらのポリシーは、役割をユーザーにマッピングできることを指定するだけで、管理者がユーザー役割マッピングタスクを実行することを許可するものではありません。管理者は、管理または役割マッピング権限も持っている必要があります。詳細については、`ユーザー権限` を参照してください。
- **map-role-composite**: 管理者がこの役割をコンポジットとして別の役割にマッピングできるかどうかを決定するポリシー。管理者は、そのクライアントの権限を管理する必要がある場合、クライアントの役割を定義できますが、コンポジットとして追加する役割の `map-role-composite` 権限がない限り、それらの役割にコンポジットを追加することはできません。
- **map-role-client-scope**: 管理者がこの役割をクライアントのスコープに適用できるかどうかを決定するポリシー。管理者がクライアントを管理できても、この権限が付与されていない限り、そのクライアントのトークンを作成して、この役割を含むことはできません。

##### クライアント

特定のクライアントの `権限` タブに移動すると、次の権限タイプが表示されます。

- **view**: 管理者がクライアントの構成を表示できるかどうかを決定するポリシー。
- **manage**: 管理者がクライアントの構成を表示して管理できるかどうかを決定するポリシー。この権限では、意図せずに権限が漏洩する可能性があるため、いくつかの問題があります。たとえば、管理者は、管理者がクライアントのスコープに役割をマッピングする権限を持っていない場合でも、役割をハードコーディングしたプロトコルマッパーを定義できます。これは、役割のように個々の権限を割り当てる方法がないため、プロトコルマッパーの現在の制限です。
- **configure**: クライアントを管理するための権限が制限されています。管理スコープに似ていますが、管理者はプロトコルマッパーを定義したり、クライアントテンプレートやクライアントのスコープを変更したりすることはできません。
- **map-roles**: 管理者がクライアントによって定義されたすべての役割をユーザーにマッピングできるかどうかを決定するポリシー。これは、クライアントによって定義されたすべての役割に対してポリシーを定義する必要がないようにするための、ショートカットで使いやすい機能です。
- **map-roles-composite**: 管理者がクライアントによって定義されたすべての役割をコンポジットとして別の役割にマッピングできるかどうかを決定するポリシー。これは、クライアントによって定義されたすべての役割に対してポリシーを定義する必要がないようにするための、ショートカットで使いやすい機能です。
- **map-roles-client-scope**: 管理者がクライアントによって定義されたすべての役割を別のクライアントのスコープにマッピングできるかどうかを決定するポリシー。これは、クライアントによって定義されたすべての役割に対してポリシーを定義する必要がないようにするための、ショートカットで使いやすい機能です。

##### ユーザー

すべてのユーザーの `権限` タブに移動すると、次の権限タイプが表示されます。

- **view**: 管理者がレルム内のすべてのユーザーを表示できるかどうかを決定するポリシー。
- **manage**: 管理者がレルム内のすべてのユーザーを管理できるかどうかを決定するポリシー。この権限は、管理者にユーザー役割マッピングを実行する権限を付与しますが、管理者がマッピングできる役割を指定するものではありません。管理者がマッピングできる役割は、役割ごと、またはクライアントの役割を扱う場合は役割セットごとに指定する必要があります。
- **map-roles**: これは、`manage` スコープによって付与された権限のサブセットです。この場合、管理者は役割をマッピングすることのみが許可されます。管理者は、他のユーザー管理操作を実行することはできません。また、`manage` と同様に、管理者が適用できる役割は、役割ごと、またはクライアントの役割を扱う場合は役割セットごとに指定する必要があります。
- **manage-group-membership**: ユーザーが追加または削除できるグループに関する役割マッピングに似ています。これらのポリシーは、管理者にグループメンバーシップを管理する権限を付与するだけで、管理者がメンバーシップを管理できるグループを指定するものではありません。各グループの `manage-members` 権限に対してポリシーを指定する必要があります。
- **impersonate**: 管理者が他のユーザーになりすますことができるかどうかを決定するポリシー。これらのポリシーは、管理者の属性と役割マッピングに適用されます。
- **user-impersonated**: どのようなユーザーになりすますことができるかを決定するポリシー。これらのポリシーは、なりすまされるユーザーに適用されます。たとえば、管理者権限を持つユーザーが、誰にもなりすまされないように、ポリシーを定義できます。

##### グループ

特定のグループの `権限` タブに移動すると、次の権限タイプが表示されます。

- **view**: 管理者がグループに関する情報を表示できるかどうかを決定するポリシー。
- **manage**: 管理者がグループの構成を管理できるかどうかを決定するポリシー。
- **view-members**: 管理者がグループのメンバーのユーザー詳細を表示できるかどうかを決定するポリシー。
- **manage-members**: 管理者がこのグループに所属するユーザーを管理できるかどうかを決定するポリシー。
- **manage-membership**: 管理者がグループのメンバーシップを変更できるかどうかを決定するポリシー。グループにメンバーを追加または削除します。

## 12. Keycloak の組織管理機能について

**組織管理** は Keycloak のプレビュー機能であり、完全にはサポートされていません。デフォルトでは無効になっています。

この機能を有効にするには、サーバーを `--features=preview` または `--features=organization` オプション付きで起動してください。

**組織管理機能とは？**

組織管理機能は、顧客やビジネスパートナーなどの第三者のアイデンティティを他のユーザーと別々に管理し、それらがあなたのビジネスエコシステムとやり取りする際に、統一された安全な体験を提供することを可能にする機能です。

Keycloak の **組織** は、これらの第三者を表すもので、管理者はそれぞれの組織に対する認証と認可を管理することができます。

**組織管理機能は、Keycloak の IAM 機能を活用し、B2B（Business-to-Business）ユースケースにも対応します。** あるレルム内において、マルチテナント機能を提供し、ユーザーはレルムの保護されたリソースにアクセスできますが、所属する組織に基づいてより制限された制御されたコンテキストでアクセスできます。

**組織管理機能の主な機能:**

- 組織メンバーの管理
- 招待リンクを使用した組織メンバーのオンボーディング
- アイデンティティブローカリングによる組織メンバーのオンボーディング（既存のアイデンティティプロバイダーとの連携）
- 組織の範囲内で認証を行う際の、アイデンティティベースのログインと組織固有の手順
- 認可目的で組織固有のクレームをトークンに伝播

> ★★★★★★★★★★★★★★★
組織管理機能については利用しないため、詳細は割愛
★★★★★★★★★★★★★★★

## 13. OpenID Connect と SAML クライアントの管理

クライアントは、ユーザーの認証を要求できるエンティティです。クライアントには2つの形式があります。1つ目は、シングルサインオンに参加したいアプリケーションです。これらのクライアントは、Keycloak にセキュリティを提供してもらうだけです。もう1つのタイプのクライアントは、認証されたユーザーに代わって他のサービスを呼び出すためにアクセス トークンを要求するクライアントです。このセクションでは、クライアントの構成と、さまざまな構成方法について説明します。

### OpenID Connect クライアントの管理

OpenID Connect は、アプリケーションを保護するための推奨されるプロトコルです。これは、最初から Web に対応するように設計されており、HTML5/JavaScript アプリケーションと最もよく連携します。

#### OpenID Connect クライアントの作成

OpenID Connect プロトコルを使用するアプリケーションを保護するには、クライアントを作成します。

**手順**

1. メニューから **クライアント** をクリックします。
2. **クライアントの作成** をクリックします。
3. **クライアント タイプ** を **OpenID Connect** に設定したままにします。
4. **クライアント ID** を入力します。
この ID は、OIDC 要求と Keycloak データベースでクライアントを識別するために使用される英数字の文字列です。
5. クライアントの **名前** を入力します。
この名前をローカライズする場合は、置換文字列値を設定します。たとえば、`$ {myapp}` などの文字列値です。詳細については、**サーバー開発者ガイド** を参照してください。
6. **保存** をクリックします。
この操作により、クライアントが作成され、**設定** タブに移動します。ここでは、**基本設定** を実行できます。

#### 基本設定

**設定** タブには、このクライアントを構成するための多くのオプションが含まれています。

##### 一般設定

* **クライアント ID**
OIDC 要求と Keycloak データベースでクライアントを識別するために使用される英数字の ID 文字列です。
* **名前**
Keycloak UI 画面のクライアントの名前です。名前をローカライズするには、置換文字列値を設定します。たとえば、`$ {myapp}` などの文字列値です。詳細については、**サーバー開発者ガイド** を参照してください。
* **説明**
クライアントの説明です。この設定はローカライズすることもできます。
* **コンソールに常に表示**
このユーザーがアクティブなセッションを持っていない場合でも、このクライアントをアカウントコンソールに常に表示します。

##### アクセス設定

* **ルート URL**
Keycloak が構成された相対 URL を使用する場合、この値がその URL の先頭に付加されます。
* **ホーム URL**
認証サーバーがクライアントにリダイレクトまたはリンクする必要がある場合のデフォルト URL を提供します。
* **有効なリダイレクト URI**
必須フィールドです。URL パターンを入力し、**+** をクリックして URL を追加し、**-** をクリックして既存の URL を削除し、**保存** をクリックします。有効なリダイレクト URI の比較には、厳密な (大文字と小文字を区別する) 文字列照合が使用されます。
URL パターンの最後にワイルドカードを使用できます。たとえば、`http://host.com/path/*` です。セキュリティ上の問題を避けるために、渡されたリダイレクト URI に `userinfo` 部分が含まれている場合、またはその `path` が親ディレクトリへのアクセスを管理する (`/../`) 場合、ワイルドカード比較は実行されず、標準的で安全な厳密な文字列照合が実行されます。
完全なワイルドカード `*` 有効なリダイレクト URI を構成して、任意の `http` または `https` リダイレクト URI を許可することもできます。本番環境では使用しないでください。
排他的なリダイレクト URI パターンは、通常、より安全です。詳細については、**非特異的なリダイレクト URI** を参照してください。
* **Web オリジン**
URL パターンを入力し、**+** をクリックして URL を追加し、**-** をクリックして既存の URL を削除します。**保存** をクリックします。
このオプションは、**クロスオリジンリソース共有 (CORS)** を処理します。ブラウザの JavaScript が、JavaScript コードの由来となったドメインとは異なるドメインのサーバーへの AJAX HTTP 要求を試みると、要求では CORS を使用する必要があります。サーバーは CORS 要求を処理する必要があり、処理しないとブラウザは要求を表示したり処理したりすることを許可しません。このプロトコルは、XSS、CSRF、その他の JavaScript ベースの攻撃から保護します。
ここにリストされているドメイン URL は、クライアントアプリケーションに送信されるアクセストークンに埋め込まれています。クライアントアプリケーションは、この情報を使用して、CORS 要求を呼び出すことを許可するかどうかを判断します。この機能をサポートしているのは、Keycloak クライアントアダプターのみです。詳細については、**アプリケーションとサービスのセキュリティガイド** を参照してください。
* **管理 URL**
クライアントのコールバックエンドポイントです。サーバーは、この URL を使用して、取り消しポリシーのプッシュ、バックチャネルログアウトの実行、その他の管理操作などのコールバックを実行します。Keycloak サーブレットアダプターの場合、この URL はサーブレットアプリケーションのルート URL にできます。詳細については、**アプリケーションとサービスのセキュリティガイド** を参照してください。

##### 機能構成

* **クライアント認証**
OIDC クライアントのタイプです。
* **オン**
ブラウザログインを実行し、アクセストークン要求を行う際にクライアントシークレットを必要とするサーバー側クライアントの場合。この設定は、サーバー側アプリケーションで使用してください。
* **オフ**
ブラウザログインを実行するクライアント側クライアントの場合。クライアント側クライアントではシークレットを安全に保つことができないため、正しいリダイレクト URI を構成してアクセスを制限することが重要です。
* **承認**
このクライアントに対するきめ細かい承認のサポートを有効または無効にします。
* **標準フロー**
有効になっている場合、このクライアントは OIDC **認証コードフロー** を使用できます。
* **ダイレクトアクセス権限**
有効になっている場合、このクライアントは OIDC **ダイレクトアクセス権限** を使用できます。
* **暗黙的なフロー**
有効になっている場合、このクライアントは OIDC **暗黙的なフロー** を使用できます。
* **サービスアカウントロール**
有効になっている場合、このクライアントは Keycloak に認証し、このクライアント専用のアクセストークンを取得できます。OAuth2 仕様の観点から、これはこのクライアントに対する **クライアント資格情報付与** のサポートを有効にします。
* **Auth 2.0 デバイス認証付与**
有効になっている場合、このクライアントは OIDC **デバイス認証付与** を使用できます。
* **OIDC CIBA 付与**
有効になっている場合、このクライアントは OIDC **クライアントが開始したバックチャネル認証付与** を使用できます。

##### ログイン設定

* **ログインテーマ**
ログイン、OTP、付与登録、パスワード忘れページに使用するテーマです。
* **同意が必要**
有効になっている場合、ユーザーはクライアントへのアクセスに同意する必要があります。
ブラウザログインを実行するクライアント側クライアントの場合。クライアント側クライアントではシークレットを安全に保つことができないため、正しいリダイレクト URI を構成してアクセスを制限することが重要です。
* **画面にクライアントを表示**
このスイッチは、**同意が必要** が **オフ** の場合に適用されます。
* **オフ**
同意画面には、構成されたクライアントスコープに対応する同意のみが表示されます。
* **オン**
このクライアントに関する項目が同意画面にも表示されます。
* **クライアント同意画面のテキスト**
**同意が必要** と **画面にクライアントを表示** が有効になっている場合に適用されます。このクライアントの権限に関する同意画面に表示されるテキストが含まれています。

##### ログアウト設定

* **フロントチャネルログアウト**
**フロントチャネルログアウト** が有効になっている場合、アプリケーションは、**OpenID Connect フロントチャネルログアウト** 仕様に従って、フロントチャネルを通じてユーザーをログアウトできます。有効になっている場合は、**フロントチャネルログアウト URL** も指定する必要があります。
* **フロントチャネルログアウト URL**
Keycloak がフロントチャネルを通じてクライアントにログアウト要求を送信するために使用する URL です。
* **バックチャネルログアウト URL**
このレルム (end_session_endpoint 経由) にログアウト要求が送信されると、クライアントがログアウトする原因となる URL です。省略すると、ログアウト要求はクライアントに送信されません。
* **バックチャネルログアウトセッションが必要**
**バックチャネルログアウト URL** が使用されている場合、ログアウトトークンにセッション ID クレームが含まれるかどうかを指定します。
* **バックチャネルログアウトオフラインセッションの取り消し**
**バックチャネルログアウト URL** が使用されている場合、ログアウトトークンに取り消しオフラインアクセスイベントが含まれるかどうかを指定します。Keycloak は、このイベントを含むログアウトトークンを受信すると、オフラインセッションを取り消します。

#### アドバンスド設定

**設定** タブのフィールドに入力したら、他のタブを使用して詳細設定を実行できます。たとえば、**権限** と **ロール** タブを使用して、管理者に対するきめ細かい認証を構成できます。**きめ細かい管理者権限** を参照してください。また、この章の残りのセクションで、他の機能について説明します。

##### 詳細タブ

**詳細** タブをクリックすると、追加のフィールドが表示されます。特定のフィールドの詳細については、そのフィールドの疑問符アイコンをクリックしてください。ただし、特定のフィールドについては、このセクションで詳しく説明します。

##### きめ細かい OpenID Connect 構成

* **ロゴ URL**
クライアントアプリケーションのロゴへの参照を持つ URL です。
* **ポリシー URL**
信頼する当事者クライアントが、エンドユーザーにプロファイルデータの使用方法について説明するために提供する URL です。
* **利用規約 URL**
信頼する当事者クライアントが、エンドユーザーに信頼する当事者の利用規約について説明するために提供する URL です。

##### 署名付きおよび暗号化された ID トークンのサポート

Keycloak は、**JSON Web Encryption (JWE)** 仕様に従って ID トークンを暗号化できます。管理者は、各クライアントに対して ID トークンが暗号化されるかどうかを決定します。

ID トークンを暗号化するために使用されるキーは、**コンテンツ暗号化キー (CEK)** です。Keycloak とクライアントは、どの CEK を使用するか、およびどのように配信するかを交渉する必要があります。CEK を決定するために使用される方法は、**キー管理モード** です。Keycloak がサポートするキー管理モードは、**キー暗号化** です。

**キー暗号化** では、次のようになります。

1. クライアントは、非対称暗号化キーペアを生成します。
2. 公開キーは、CEK を暗号化するために使用されます。
3. Keycloak は、ID トークンごとに CEK を生成します。
4. Keycloak は、生成された CEK を使用して ID トークンを暗号化します。
5. Keycloak は、クライアントの公開キーを使用して CEK を暗号化します。
6. クライアントは、自分の秘密キーを使用して暗号化された CEK を復号化します。
7. クライアントは、復号化された CEK を使用して ID トークンを復号化します。

クライアント以外の当事者は、ID トークンを復号化できません。

クライアントは、CEK を暗号化するための公開キーを Keycloak に渡す必要があります。Keycloak は、クライアントが提供した URL から公開キーをダウンロードすることをサポートしています。クライアントは、**JSON Web Keys (JWK)** 仕様に従って公開キーを提供する必要があります。

**手順**

1. クライアントの **キー** タブを開きます。
2. **JWKS URL** を **オン** に切り替えます。
3. **JWKS URL** テキストボックスにクライアントの公開キーの URL を入力します。

**キー暗号化** のアルゴリズムは、**JSON Web Algorithm (JWA)** 仕様で定義されています。Keycloak は次のアルゴリズムをサポートしています。

* RSAES-PKCS1-v1_5(RSA1_5)
* デフォルトのパラメータを使用した RSAES OAEP (RSA-OAEP)
* SHA-256 と MFG1 を使用した RSAES OAEP 256 (RSA-OAEP-256)

アルゴリズムを選択する手順は次のとおりです。

1. クライアントの **詳細** タブを開きます。
2. **きめ細かい OpenID Connect 構成** を開きます。
3. **ID トークン暗号化コンテンツ暗号化アルゴリズム** プルダウンメニューからアルゴリズムを選択します。

##### OpenID Connect 互換性モード

このセクションは、下位互換性のために存在します。各フィールドの詳細については、疑問符アイコンをクリックしてください。

* **OAuth 2.0 相互 TLS 証明書バインドアクセストークン有効**
相互 TLS は、アクセストークンとリフレッシュトークンを TLS ハンドシェイク中に交換されるクライアント証明書にバインドします。このバインドにより、攻撃者は盗難されたトークンを使用できなくなります。

このタイプのトークンは、**キー保持者トークン** です。ベアラートークンとは異なり、キー保持者トークンの受信者は、トークンの送信者が正当かどうかを確認できます。

この設定がオンの場合、ワークフローは次のようになります。

1. トークン要求が、認証コードフローまたはハイブリッドフローのトークンエンドポイントに送信されます。
2. Keycloak は、クライアント証明書を要求します。
3. Keycloak は、クライアント証明書を受信します。
4. Keycloak は、クライアント証明書を正常に検証します。
5. 検証に失敗すると、Keycloak はトークンを拒否します。

次の場合、Keycloak は、アクセストークンまたはリフレッシュトークンを送信するクライアントを検証します。

* トークン要求が、キー保持者リフレッシュトークンを使用してトークンエンドポイントに送信されます。
* UserInfo 要求が、キー保持者アクセストークンを使用して UserInfo エンドポイントに送信されます。
* ログアウト要求が、キー保持者リフレッシュトークンを使用して、非 OIDC 準拠の Keycloak 専用ログアウトエンドポイントに送信されます。

詳細については、**OAuth 2.0 相互 TLS クライアント証明書バインドアクセストークン** (OAuth 2.0 相互 TLS クライアント認証と証明書バインドアクセストークンのセクションを参照) を参照してください。

* **OAuth 2.0 アプリケーションレイヤーでの所有権証明の提示 (DPoP)**
DPoP は、アクセストークンとリフレッシュトークンを、クライアントのキーペアの公開部分にバインドします。このバインドにより、攻撃者は盗難されたトークンを使用できなくなります。

このタイプのトークンは、**キー保持者トークン** です。ベアラートークンとは異なり、キー保持者トークンの受信者は、トークンの送信者が正当かどうかを確認できます。

クライアントスイッチ **OAuth 2.0 DPoP バインドアクセストークン有効** がオンの場合、ワークフローは次のようになります。

1. トークン要求が、認証コードフローまたはハイブリッドフローのトークンエンドポイントに送信されます。
2. Keycloak は、DPoP 証明を要求します。
3. Keycloak は、DPoP 証明を受信します。
4. Keycloak は、DPoP 証明を正常に検証します。
5. 検証に失敗すると、Keycloak はトークンを拒否します。

**OAuth 2.0 DPoP バインドアクセストークン有効** スイッチがオフの場合、クライアントはトークン要求に DPoP 証明を送信できます。その場合、Keycloak は DPoP 証明を検証し、フィンガープリントをトークンに追加します。ただし、スイッチがオフの場合、Keycloak サーバーはこのクライアントに対して DPoP バインドを強制しません。特定のクライアントが常に DPoP バインドを使用するようにする場合は、このスイッチをオンにすることをお勧めします。

次の場合、Keycloak は、アクセストークンまたはリフレッシュトークンを送信するクライアントを検証します。

* トークン要求が、キー保持者リフレッシュトークンを使用してトークンエンドポイントに送信されます。この検証は、DPoP 仕様で説明されているように、公開クライアントに対してのみ行われます。機密クライアントの場合、検証は行われません。適切なクライアント資格情報を使用してクライアント認証が実行され、要求が正当なクライアントから来ていることを確認します。公開クライアントの場合、アクセストークンとリフレッシュトークンの両方が DPoP バインドされます。機密クライアントの場合、アクセストークンのみが DPoP バインドされます。
* UserInfo 要求が、キー保持者アクセストークンを使用して UserInfo エンドポイントに送信されます。
* ログアウト要求が、キー保持者リフレッシュトークンを使用して、非 OIDC 準拠の Keycloak 専用ログアウトエンドポイントログアウトエンドポイントに送信されます。この検証は、上記のように、公開クライアントに対してのみ行われます。

詳細については、**OAuth 2.0 所有権証明の提示 (DPoP)** を参照してください。

DPoP は **プレビュー** 機能であり、完全にサポートされていません。この機能は、デフォルトでは無効になっています。

有効にするには、サーバーを `--features=preview` または `--features=dpop` で起動します。

##### OIDC の詳細設定

OpenID Connect の詳細設定を使用すると、セッションとトークンのタイムアウトについて、クライアントレベルでオーバーライドを構成できます。

| 設定 | 説明 |
|-----------------------------------------|---------------------------------------------------------------------------|
| アクセストークン有効期間 | 同じ名前のレルムオプションをオーバーライドします。 |
| クライアントセッションアイドル | 同じ名前のレルムオプションをオーバーライドします。値は、グローバルな SSO セッションアイドルよりも短くする必要があります。 |
| クライアントセッション最大 | 同じ名前のレルムオプションをオーバーライドします。値は、グローバルな SSO セッション最大よりも短くする必要があります。 |
| クライアントオフラインセッションアイドル | この設定を使用すると、クライアントのオフラインセッションアイドルタイムアウトを短く構成できます。タイムアウトは、Keycloak がオフライントークンを取り消すまでにセッションがアイドル状態になる時間です。設定しない場合は、レルムの **オフラインセッションアイドル** が使用されます。 |
| クライアントオフラインセッション最大 | この設定を使用すると、クライアントのオフラインセッション最大有効期間を短く構成できます。有効期間は、Keycloak が対応するオフライントークンを取り消すまでの最大時間です。このオプションを使用するには、レルムで **オフラインセッション最大制限** を有効にする必要があり、デフォルトでは **オフラインセッション最大** になります。 |
| コード交換コードチャレンジメソッドの証明キー | 攻撃者が正当なクライアントの認証コードを盗んだ場合、コード交換の証明 (PKCE) は攻撃者がコードに適用されるトークンを取得できないようにします。 |
| | 管理者は、次のオプションのいずれかを選択できます。 |
| | - (空白) |
| | - Keycloak は、クライアントが Keycloak の承認エンドポイントに適切な PKCE パラメータを送信しない限り、PKCE を適用しません。 |
| | - S256 |
| | - Keycloak は、コードチャレンジメソッドが S256 であるクライアントの PKCE に適用します。 |
| | - plain |
| | - Keycloak は、コードチャレンジメソッドが plain であるクライアントの PKCE に適用します。 |
| | 詳細については、**RFC 7636 OAuth 公開クライアントによるコード交換の証明キー** を参照してください。 |
| ACR 認証レベル (LoA) マッピング | クライアントの詳細設定で、どの **認証コンテキストクラス参照 (ACR)** 値がどの **認証レベル (LoA)** にマッピングされるかを定義できます。このマッピングは、**ACR 認証レベル (LoA) マッピング** に示されているように、レルムでも指定できます。ベストプラクティスは、レルムレベルでこのマッピングを構成することです。これにより、複数のクライアント間で同じ設定を共有できます。 |
| | **デフォルトの ACR 値** を使用して、ログイン要求が **acr_values** パラメータなし、または **acr** クレームが添付された **claims** パラメータなしで Keycloak に送信された場合のデフォルト値を指定できます。**公式 OIDC 動的クライアント登録仕様** を参照してください。 |
| | デフォルトの ACR 値は、デフォルトレベルとして使用されますが、特定のレベルでログインを強制するために確実に使用することはできません。たとえば、**デフォルトの ACR 値** をレベル 2 に構成するとします。そうすると、デフォルトでは、ユーザーはレベル 2 で認証する必要があります。ただし、ユーザーがログイン要求に明示的に `acr_values=1` などのパラメータを添付すると、レベル 1 が使用されます。結果として、クライアントがレベル 2 を実際に必要とする場合、クライアントは ID トークン内の **acr** クレームの存在を確認し、要求されたレベル 2 が含まれているかどうかを再確認する必要があります。 |
| | 詳細については、**ステップアップ認証** と **公式 OIDC 仕様** を参照してください。 |

#### 機密クライアント資格情報

クライアントの **クライアント認証** が **オン** に設定されている場合、クライアントの資格情報は **資格情報** タブで構成する必要があります。

資格情報タブ

**クライアント認証子** ドロップダウンリストでは、クライアントに使用する資格情報のタイプを指定します。

##### **クライアント ID とシークレット**
これがデフォルト設定です。シークレットは自動的に生成されます。必要に応じて、**再生成** をクリックしてシークレットを再作成します。

* **署名付き JWT**
**署名付き JSON Web トークン** です。

この資格情報タイプを選択すると、**キー** タブでクライアントの秘密キーと証明書を生成する必要もあります。秘密キーは JWT に署名するために使用され、証明書はサーバーが署名を検証するために使用されます。

**キータブ**

**新しいキーを生成** ボタンをクリックして、このプロセスを開始します。

1. 使用するアーカイブ形式を選択します。
2. **キーパスワード** を入力します。
3. **ストアパスワード** を入力します。
4. **生成** をクリックします。

キーを生成すると、Keycloak は証明書を保存し、クライアントの秘密キーと証明書をダウンロードできます。

また、外部ツールを使用してキーを生成し、**証明書のインポート** をクリックしてクライアントの証明書をインポートすることもできます。

**証明書のインポート**

1. 証明書のアーカイブ形式を選択します。
2. **ストアパスワード** を入力します。
3. **ファイルのインポート** をクリックして、証明書ファイルを選択します。
4. **インポート** をクリックします。

**JWKS URL を使用する** をクリックすると、証明書のインポートは不要になります。この場合、公開キーが **JWK** 形式で公開されている URL を指定できます。このオプションを使用すると、キーが変更された場合、Keycloak はキーを再インポートします。

Keycloak アダプターで保護されているクライアントを使用している場合は、クライアントアプリケーションのルート URL が `https://myhost.com/myapp` であると仮定して、この形式で JWKS URL を構成できます。

`https://myhost.com/myapp/k_jwks`

詳細については、**サーバー開発者ガイド** を参照してください。

##### **クライアントシークレット付き署名付き JWT**
このオプションを選択すると、秘密キーの代わりにクライアントシークレットで署名された JWT を使用できます。

クライアントシークレットは、クライアントが JWT に署名するために使用されます。

##### **X509 証明書**
Keycloak は、クライアントが TLS ハンドシェイク中に適切な X509 証明書を使用しているかどうかを検証します。

検証者は、構成された正規表現検証式を使用して、証明書のサブジェクト DN フィールドもチェックします。一部のユースケースでは、すべての証明書を受け入れるだけで十分です。その場合、`(.*?)(?:$)` 式を使用できます。

Keycloak が要求からクライアント ID を取得する方法は、2つあります。

* **クエリ** の `client_id` パラメータ (**OAuth 2.0 仕様** のセクション 2.2 に記載)。
* **フォームパラメータ** として `client_id` を指定します。

#### クライアントシークレットローテーション

クライアントシークレットローテーションのサポートは、開発中です。この機能は実験的に使用してください。

**機密** クライアント認証を持つクライアントの場合、Keycloak は **クライアントポリシー** を通じてクライアントシークレットをローテーションする機能をサポートしています。

クライアントシークレットローテーションポリシーは、シークレット漏洩などの問題を軽減するために、より高いセキュリティを提供します。有効にすると、Keycloak は各クライアントに対して最大2つのアクティブなシークレットを同時にサポートします。ポリシーは、次の設定に従ってローテーションを管理します。

* **シークレット有効期限:** [秒] - シークレットがローテーションされると、これは新しいシークレットの有効期限です。シークレット作成日に追加される秒数です。ポリシーの実行時に計算されます。
* **ローテーションされたシークレットの有効期限:** [秒] - シークレットがローテーションされると、この値は古いシークレットの残りの有効期限です。この値は、常に **シークレット有効期限** より小さくする必要があります。値が 0 の場合、古いシークレットはクライアントのローテーション中にすぐに削除されます。シークレットローテーション日に追加される秒数です。ポリシーの実行時に計算されます。
* **更新中のローテーションの残りの有効期限:** [秒] - 動的クライアントの更新がクライアントシークレットローテーションを実行する必要がある期間です。ポリシーの実行時に計算されます。

クライアントシークレットローテーションが発生すると、新しいメインシークレットが生成され、古いクライアントメインシークレットは、新しい有効期限を持つセカンダリシークレットになります。

##### クライアントシークレットローテーションのルール

ローテーションは、自動的またはバックグラウンドプロセスを通じて行われません。ローテーションを実行するには、クライアントの更新アクションが必要です。これは、Keycloak 管理コンソールの **シークレットの再生成** 機能 (クライアントの資格情報タブ) または管理 REST API を通じて行います。クライアントの更新アクションを呼び出すと、シークレットローテーションは次のルールに従って実行されます。

* **シークレット有効期限** の値が現在の日付よりも小さい場合。
* 動的クライアント登録のクライアント更新要求中に、**更新中のローテーションの残りの有効期限** の値が、現在の日付と **シークレット有効期限** の間の期間と一致する場合、クライアントシークレットは自動的にローテーションされます。

さらに、管理 REST API を通じて、いつでもクライアントシークレットローテーションを強制することができます。

新しいクライアントを作成する際に、クライアントシークレットローテーションポリシーがアクティブな場合、動作は自動的に適用されます。

既存のクライアントにシークレットローテーション動作を適用するには、ポリシーを定義した後にクライアントを更新して、動作が適用されるようにします。

#### OIDC クライアントシークレットローテーションポリシーの作成

以下は、シークレットローテーションポリシーを定義する例です。

**手順**

1. メニューから **レルム設定** をクリックします。
2. **クライアントポリシー** タブをクリックします。
3. **プロファイル** ページで、**クライアントプロファイルの作成** をクリックします。
4. **名前** に任意の名前を入力します。
5. **説明** に、プロファイルの目的を特定するのに役立つ説明を入力します。
6. **保存** をクリックします。
この操作により、プロファイルが作成され、実行者を構成できるようになります。
7. **実行者の追加** をクリックして、このプロファイルの実行者を構成します。
8. **実行者タイプ** に **secret-rotation** を選択します。
9. **シークレット有効期限** に、各シークレットの最大期間 (秒単位) を入力します。
10. **ローテーションされたシークレットの有効期限** に、各ローテーションされたシークレットの最大期間 (秒単位) を入力します。
**ローテーションされたシークレットの有効期限** の値は、常に **シークレット有効期限** より小さくする必要があります。
11. **残り有効期限** に、更新アクションがクライアントを更新するまでの時間 (秒単位) を入力します。
12. **追加** をクリックします。
上記の例では、次のようになります。
* 各シークレットは 1 週間有効です。
* ローテーションされたシークレットは、2 日後に期限切れになります。
* 動的クライアントを更新するウィンドウは、シークレットの期限切れの 1 日前に始まります。
13. **クライアントポリシー** タブに戻ります。
14. **ポリシー** をクリックします。
15. **クライアントポリシーの作成** をクリックします。
16. **名前** に任意の名前を入力します。
17. **説明** に、ポリシーの目的を特定するのに役立つ説明を入力します。
18. **保存** をクリックします。
この操作により、ポリシーが作成され、プロファイルにポリシーを関連付けることができます。また、ポリシー実行の条件を構成することもできます。
19. **条件** で、**条件の追加** をクリックします。
20. **条件タイプ** フィールドに、すべての機密クライアントに動作を適用する場合は **client-access-type** を選択します。
特定のクライアントグループに適用する場合は、**条件タイプ** フィールドに **client-roles** タイプを選択できます。このようにして、特定のロールを作成し、各ロールにカスタムローテーション構成を割り当てることができます。
21. **クライアントアクセス タイプ** フィールドに **confidential** を追加します。
22. **追加** をクリックします。
23. ポリシー設定に戻り、**クライアントプロファイル** で **クライアントプロファイルの追加** をクリックし、リストから **Weekly Client Secret Rotation Profile** を選択して、**追加** をクリックします。

シークレットローテーション動作を既存のクライアントに適用するには、次の手順に従います。

**管理コンソールを使用する場合**

1. メニューから **クライアント** をクリックします。
2. クライアントをクリックします。
3. **資格情報** タブをクリックします。
4. クライアントシークレットの **再生成** をクリックします。

**クライアント REST サービスを使用する場合**

* クライアントに対する更新操作を通じて。
* クライアントシークレットの再生成エンドポイントを通じて。

#### サービスアカウントを使用する

各 OIDC クライアントには、組み込みの **サービスアカウント** があります。この **サービスアカウント** を使用して、アクセストークンを取得します。

**手順**

1. メニューから **クライアント** をクリックします。
2. クライアントを選択します。
3. **設定** タブをクリックします。
4. **クライアント認証** を **オン** に切り替えます。
5. **サービスアカウントロール** を選択します。
6. **保存** をクリックします。
7. **クライアント資格情報** を構成します。
8. **スコープ** タブをクリックします。
9. ロールがあることを確認するか、**完全なスコープを許可** を **オン** に切り替えます。
10. **サービスアカウントロール** タブをクリックします。
11. クライアントのサービスアカウントで使用可能なロールを構成します。

アクセストークンのロールは、次のものの交差です。

* クライアントのロールスコープマッピング
* 関連付けられたクライアントスコープから継承されたロールスコープマッピング
* サービスアカウントロール

呼び出す REST URL は、`/realms/{realm-name}/protocol/openid-connect/token` です。この URL は POST 要求として呼び出す必要があり、要求と共にクライアント資格情報を投稿する必要があります。

デフォルトでは、クライアント資格情報は、`Authorization: Basic` ヘッダーのクライアントの `clientId` と `clientSecret` によって表されますが、クライアントを署名付き JWT アサーションまたはクライアント認証のためのその他のカスタムメカニズムで認証することもできます。

また、OAuth2 仕様に従って、`grant_type` パラメータを "client_credentials" に設定する必要があります。

たとえば、サービスアカウントを取得するための POST 呼び出しは、次のようになります。

```
POST /realms/demo/protocol/openid-connect/token
Authorization: Basic cHJvZHVjdC1zYS1jbGllbnQ6cGFzc3dvcmQ=
Content-Type: application/x-www-form-urlencoded

grant_type=client_credentials
```

応答は、OAuth 2.0 仕様の **アクセストークン応答** と似ています。

```
HTTP/1.1 200 OK
Content-Type: application/json;charset=UTF-8
Cache-Control: no-store
Pragma: no-cache

{
"access_token":"2YotnFZFEjr1zCsicMWpAA",
"token_type":"bearer",
"expires_in":60
}
```

デフォルトでは、アクセストークンのみが返されます。リフレッシュトークンは返されず、Keycloak 側では、認証が成功したときにユーザーセッションは作成されません。リフレッシュトークンがないため、アクセストークンの有効期限が切れると再認証が必要になります。ただし、この状況は Keycloak サーバーに追加のオーバーヘッドを意味するわけではありません。セッションはデフォルトでは作成されないためです。

この状況では、ログアウトは不要です。ただし、発行されたアクセストークンは、**OpenID Connect エンドポイント** セクションで説明されているように、OAuth2 取り消しエンドポイントに要求を送信することで取り消すことができます。

追加のリソース

詳細については、**クライアント資格情報付与** を参照してください。

#### オーディエンスサポート

一般的に、Keycloak が展開されている環境は、認証に Keycloak を使用する一連の**機密**または**公開**クライアントアプリケーションで構成されています。

**サービス** (OAuth 2 仕様における**リソースサーバー**) も、クライアントアプリケーションからのリクエストを処理し、これらのアプリケーションにリソースを提供するために利用できます。これらのサービスは、リクエストを認証するために**アクセス トークン** (ベアラー トークン) を送信する必要があります。このトークンは、フロントエンドアプリケーションが Keycloak にログインすると取得されます。

サービス間の信頼度が低い環境では、次のようなシナリオが発生する可能性があります。

1. フロントエンドクライアントアプリケーションは、Keycloak に対して認証が必要です。
2. Keycloak はユーザーを認証します。
3. Keycloak はアプリケーションにトークンを発行します。
4. アプリケーションは、トークンを使用して信頼されていないサービスを呼び出します。
5. 信頼されていないサービスは、アプリケーションにレスポンスを返しますが、アプリケーションのトークンは保持します。
6. 信頼されていないサービスは、アプリケーションのトークンを使用して信頼されているサービスを呼び出します。これにより、信頼されていないサービスがクライアントアプリケーションに代わって他のサービスにアクセスするためにトークンを不正使用するため、セキュリティが損なわれます。

このシナリオは、サービス間の信頼レベルが高い環境では起こりそうにありませんが、信頼レベルが低い環境では起こる可能性があります。一部の環境では、信頼されていないサービスが信頼されているサービスからデータを取得して元のクライアントアプリケーションにデータ返す必要があるため、このワークフローが正しい場合があります。

サービス間に高い信頼レベルが存在する場合、無制限のオーディエンスサポートが役立ちます。それ以外の場合は、オーディエンスサポートを制限する必要があります。オーディエンスサポートを制限し、同時に信頼されていないサービスが信頼されているサービスからデータを取得できるようにすることができます。この場合、信頼されていないサービスと信頼されているサービスの両方をトークンのオーディエンスサポートとして追加してください。

アクセストークンの不正使用を防ぐために、トークンのオーディエンスサポートを制限し、サービスを構成してトークンのオーディエンスサポートを検証します。フローは次のように変化します。

1. フロントエンドアプリケーションは Keycloak に対して認証を行います。
2. Keycloak はユーザーを認証します。
3. Keycloak はアプリケーションにトークンを発行します。アプリケーションは信頼されていないサービスを呼び出す必要があることを知っているため、Keycloak に送信される認証リクエストに**scope=<untrusted service>**を配置します (**scope**パラメーターの詳細については、**クライアントスコープ**セクションを参照してください)。
4. アプリケーションに発行されたトークンには、そのオーディエンスサポート (**"audience": [ "<untrusted service>" ]**) に信頼されていないサービスへの参照が含まれ、クライアントがこのアクセストークンを使用して信頼されていないサービスを呼び出すことを宣言しています。
5. 信頼されていないサービスは、トークンを使用して信頼されているサービスを呼び出します。信頼されているサービスはトークンのオーディエンスサポートをチェックし、そのオーディエンスサポートが信頼されていないサービスのみであることが判明するため、呼び出しは成功しません。これは予想される動作であり、セキュリティは損なわれません。
6. クライアントが後で信頼されているサービスを呼び出す必要がある場合は、**scope=<trusted service>**で SSO ログインを再発行することで別のトークンを取得する必要があります。返されたトークンには、信頼されているサービスがオーディエンスサポートとして含まれます: **"audience": [ "<trusted service>" ]**
7. この値を使用して**<trusted service>**を呼び出します。

#### 設定

オーディエンスサポートのチェックを設定する際に、以下の点を確認してください。

* サービスが、それらに送信されるアクセストークンのオーディエンスサポートをチェックするように構成されていることを確認します。これは、OIDC クライアントアプリケーションのセキュリティに使用しているクライアント OIDC アダプター固有の方法で行うことができます。
* Keycloak によって発行されるアクセストークンに、必要なすべてのオーディエンスサポートが含まれていることを確認します。オーディエンスサポートは、次のセクションで説明されているクライアントロールを使用して追加するか、ハードコードすることができます。**ハードコードされたオーディエンスサポート**を参照してください。

#### 自動的にオーディエンスサポートを追加する

**オーディエンスサポート解決**プロトコルマッパーは、デフォルトのクライアントスコープロールに定義されています。マッパーは、現在のトークンに対して利用可能なクライアントロールが少なくとも 1 つあるクライアントをチェックします。その後、各クライアントのクライアント ID がオーディエンスサポートとして追加されます。これは、サービスクライアントがクライアントロールに依存する場合に役立ちます。サービスクライアントは通常、フローが有効になっていないクライアントであり、直接発行されるトークンがない場合があります。これは、OAuth 2 リソースサーバーを表します。

たとえば、サービスクライアントと機密クライアントの場合、機密クライアントに発行されたアクセストークンを使用して、サービスクライアントの REST サービスを呼び出すことができます。サービスクライアントに次の条件が当てはまる場合、サービスクライアントは機密クライアントに発行されたアクセストークンのオーディエンスサポートとして自動的に追加されます。

* サービスクライアントに定義されたクライアントロールがあります。
* ターゲットユーザーに、これらのクライアントロールの少なくとも 1 つが割り当てられています。
* 機密クライアントに、割り当てられたロールのロールスコープマッピングがあります。

オーディエンスサポートが自動的に追加されないようにするには、機密クライアントに直接ロールスコープマッピングを構成しないでください。代わりに、専用のクライアントスコープを作成して、専用のクライアントスコープのクライアントロールのロールスコープマッピングを含めることができます。

クライアントスコープが機密クライアントにオプションのクライアントスコープとして追加されていると想定すると、**scope=<trusted service>**パラメーターで明示的に要求された場合、クライアントロールとオーディエンスサポートがトークンに追加されます。

フロントエンドクライアント自体はアクセストークンのオーディエンスサポートに自動的に追加されないため、アクセストークンと ID トークンを簡単に区別できます。アクセストークンには、トークンが発行されたクライアントがオーディエンスサポートとして含まれません。

クライアント自体をオーディエンスサポートとして必要とする場合は、**ハードコードされたオーディエンスサポート**オプションを参照してください。ただし、フロントエンドと REST サービスの両方で同じクライアントを使用することはお勧めしません。

#### ハードコードされたオーディエンスサポート

サービスがレルムロールに依存するか、またはトークンのロールにまったく依存しない場合は、ハードコードされたオーディエンスサポートを使用すると便利です。ハードコードされたオーディエンスサポートは、指定されたサービスクライアントのクライアント ID をトークンのオーディエンスサポートとして追加するプロトコルマッパーです。クライアント ID 以外のオーディエンスサポートを使用する場合は、URL など、任意のカスタム値を使用できます。

プロトコルマッパーをフロントエンドクライアントに直接追加できます。プロトコルマッパーが直接追加されると、オーディエンスサポートも常に追加されます。

プロトコルマッパーをより細かく制御するには、**good-service**と呼ばれる専用のクライアントスコープにプロトコルマッパーを作成できます。

**オーディエンスサポート**プロトコルマッパー

<start_of_image> ****

**good-service**クライアントの**クライアント詳細**タブから、アダプター構成を生成して**verify-token-audience**が**true**に設定されていることを確認できます。このアクションにより、この構成を使用する場合、アダプターはオーディエンスサポートを検証するように強制されます。

機密クライアントがトークンのオーディエンスサポートとして**good-service**を要求できることを確認する必要があります。

機密クライアントで:

1. **クライアントスコープ**タブをクリックします。
2. **good-service**をオプションの (またはデフォルトの) クライアントスコープとして割り当てます。
3. 詳細については、**クライアントスコープのリンク**セクションを参照してください。

オプションで**クライアントスコープの評価**を行い、アクセストークンの例を生成できます。**good-service**をオプションのクライアントスコープとして割り当てた場合、**scope**パラメーターに**good-service**が含まれていると、生成されたアクセストークンのオーディエンスサポートに**good-service**が追加されます。

機密クライアントアプリケーションで、**scope**パラメーターが使用されていることを確認してください。**good-service**にアクセスするためのトークンを発行する場合、**good-service**という値を含める必要があります。

参照:

* アプリケーションが JavaScript アダプターを使用している場合は、**JavaScript アダプター**セクションを参照してください。

デフォルトでは、**オーディエンスサポート**と**オーディエンスサポート解決**の両方のプロトコルマッパーは、アクセストークンにのみオーディエンスサポートを追加します。ID トークンには、通常、トークンが発行されたクライアントのクライアント ID である単一のオーディエンスサポートのみが含まれます。これは、OpenID Connect 仕様の要件です。ただし、アクセストークンには、オーディエンスサポートマッパーが追加しない限り、トークンが発行されたクライアント ID が含まれない場合があります。

### SAML クライアントの作成

Keycloakは登録されたアプリケーション向けにSAML 2.0をサポートしています。POSTとリダイレクトのバインディングがサポートされています。クライアント署名検証を要求することもできます。また、サーバーが応答に署名と/または暗号化することも可能です。

> ★★★★★★★★★★★★★★★
SAML クライアントについては利用しないため、詳細は割愛
★★★★★★★★★★★★★★★


### クライアント間のリンク

Keycloak は、クライアント間をリンクするためのリダイレクトエンドポイント `/realms/realm_name/clients/{client-id}/redirect` を提供しています。

クライアントがこのエンドポイントに HTTP GET リクエストでアクセスすると、Keycloak は、提供されたクライアントとレルムの構成済みベース URL を HTTP 307 (一時的なリダイレクト) の形で、レスポンスの Location ヘッダーに返します。この結果、クライアントはレルム名とクライアント ID のみを認識していれば、それらにリンクできます。この間接化により、クライアントのベース URL をハードコードする必要がなくなります。

例えば、レルム `master` とクライアント ID `account` の場合、次の URL は一時的にリダイレクトされます。

```
http://host:port/realms/master/clients/account/redirect
```

リダイレクト先は次のようになります。

```
http://host:port/realms/master/account
```

### OIDC トークンと SAML アサーションの対応付け

ID トークン、アクセス トークン、または SAML アサーションを受け取るアプリケーションでは、異なるロールとユーザーメタデータが必要になる場合があります。

Keycloak を使用して、次のようなことができます。

* ロール、クレーム、カスタム属性をハードコードする。
* ユーザーメタデータをトークンまたはアサーションに引き込む。
* ロール名を変更する。

これらの操作は、管理コンソールの**マッパー**タブで行います。

**マッパータブ**

新しいクライアントには、組み込みのマッパーはありませんが、クライアントスコープから一部のマッパーを継承することができます。詳細については、クライアントスコープのセクションを参照してください。

プロトコルマッパーは、アイテム (例：メールアドレス) をアイデンティティとアクセストークンの特定のクレームにマッピングします。マッパーの機能は、名前から自明です。事前構成済みのマッパーを追加するには、**組み込みを追加**をクリックします。

各マッパーには、共通の設定があります。追加の設定は、マッパーの種類によって異なります。マッパーの横にある**編集**をクリックすると、構成画面にアクセスしてこれらの設定を調整できます。

**マッパーの構成**

各オプションの詳細については、ツールチップにマウスを合わせると表示されます。

ほとんどの OIDC マッパーは、クレームが配置される場所を制御するために使用できます。**ID トークンに追加**と**アクセス トークンに追加**スイッチを調整することで、クレームを ID トークンとアクセストークンに含めるか、除外するかを選択できます。

マッパーの種類は、次のように追加できます。

**手順**

1. **マッパー**タブに移動します。
2. **新しいマッパーを構成**をクリックします。

**マッパーの追加**

リストボックスから**マッパーの種類**を選択します。

#### 優先順位

マッパーの実装には、**優先順位**があります。優先順位は、マッパーの構成プロパティではなく、マッパーの実装の具体的なプロパティです。

マッパーは、マッパーのリスト内の順序でソートされます。トークンまたはアサーションに対する変更は、その順序で適用され、最も低い優先順位が最初に適用されます。そのため、他の実装に依存する実装は、必要な順序で処理されます。

例えば、トークンに含まれるロールを計算する場合、次のようになります。

1. ロールに基づいて、対象者を解決する。
2. トークンにすでに存在するロールと対象者を使用する JavaScript スクリプトを処理する。

#### OIDC ユーザーセッションノートマッパー

ユーザーセッションの詳細情報は、マッパーを使用して定義され、クライアントで機能を使用または有効にすると自動的に含まれます。セッションの詳細情報を含めるには、**組み込みを追加**をクリックします。

なりすましユーザーセッションは、次の詳細情報を提供します。

* **IMPERSONATOR_ID**: なりすましユーザーの ID
* **IMPERSONATOR_USERNAME**: なりすましユーザーのユーザー名

サービスアカウントセッションは、次の詳細情報を提供します。

* **clientId**: サービスアカウントのクライアント ID
* **client_id**: サービスアカウントのクライアント ID
* **clientAddress**: サービスアカウントの認証されたデバイスのリモートホスト IP
* **clientHost**: サービスアカウントの認証されたデバイスのリモートホスト名

#### スクリプトマッパー

**スクリプトマッパー**を使用して、ユーザー定義の JavaScript コードを実行することで、クレームをトークンにマッピングします。サーバーへのスクリプトの展開の詳細については、JavaScript プロバイダーを参照してください。

スクリプトが展開されると、利用可能なマッパーのリストから展開されたスクリプトを選択できるようになります。

#### ペアリングされたサブジェクト識別子マッパー

サブジェクトクレーム `sub` は、デフォルトのクライアントスコープ `basic` の **サブジェクト (sub)** プロトコルマッパーによってデフォルトでマッピングされます。

**ペアリングされたサブジェクト識別子**を **ペアリングされたサブジェクト識別子**などのプロトコルマッパーを使用して使用するには、`basic` クライアントスコープから **サブジェクト (sub)** プロトコルマッパーを削除できます。ただし、**サブジェクト (sub)** プロトコルマッパーは **ペアリングされたサブジェクト識別子** マッパーよりも前に実行されるため、厳密には必要ありません。そのため、ペアリングされた値は、サブジェクトマッパーによって追加された値をオーバーライドします。これは、サブジェクトマッパーの**優先順位**によるものです。そのため、組み込みの **サブジェクト (sub)** マッパーを削除することの唯一の利点は、プロトコルマッパーの使用を回避することでパフォーマンスをわずかに向上できる可能性があることです。これは、効果がない場合もあります。

#### 軽量アクセストークンの使用

Keycloak のアクセストークンには、個人識別情報 (PII) を含む機密情報が含まれています。そのため、リソースサーバーがクライアントなどの第三者にこの種の情報を公開したくない場合、Keycloak はアクセストークンから PII を削除する軽量アクセストークンをサポートしています。さらに、リソースサーバーがアクセストークンから削除された PII を取得する場合、アクセストークンを Keycloak のトークンイントロスペクションエンドポイントに送信することで PII を取得できます。

##### 軽量アクセストークンから削除できない情報

プロトコルマッパーは、アクセストークンにどの情報が入れられるかを制御します。軽量アクセストークンは、プロトコルマッパーを使用します。そのため、次の情報は、軽量アクセスから削除できません。

* `exp`, `iat`, `jti`, `iss`, `typ`, `azp`, `sid`, `scope`, `cnf`

##### Keycloak で軽量アクセストークンを使用する

**クライアントポリシー**の **use-lightweight-access-token** 実行者をクライアントに適用することで、クライアントはアクセストークンの代わりに軽量アクセストークンを受け取ることができます。軽量アクセストークンには、設定が **軽量アクセストークンに追加 (デフォルトで OFF)** に設定されているプロトコルマッパーによって制御されるクレームが含まれています。また、プロトコルマッパーの設定 **トークンイントロスペクションに追加** を ON にすることで、クライアントはアクセストークンを Keycloak のトークンイントロスペクションエンドポイントに送信することで、クレームを取得できます。

##### イントロスペクションエンドポイント

場合によっては、HTTP ヘッダー **Accept: application/jwt** を使用して、**Accept: application/json** の代わりにトークンイントロスペクションエンドポイントをトリガーすると便利です。これは、特に軽量アクセストークンに役立ちます。詳細については、トークンイントロスペクションエンドポイントのセクションを参照してください。

### クライアントアダプタ構成の生成

Keycloakは、アプリケーションのデプロイメント環境にクライアントアダプタをインストールするために使用できる構成ファイルを生成できます。OIDCとSAMLに対して、多くのアダプタタイプがサポートされています。

**アクションメニュー**をクリックし、**アダプタ構成のダウンロード**オプションを選択します。

**フォーマットオプション**を選択して、生成する構成のフォーマットを指定します。

OIDCとSAMLのすべてのKeycloakクライアントアダプタがサポートされています。SAML用のmod-auth-mellon Apache HTTPDアダプタと、標準のSAMLエンティティ記述ファイルもサポートされています。

### クライアントスコープ

Keycloakでは、クライアントスコープと呼ばれるエンティティを使用して、クライアントの共有設定を定義できます。クライアントスコープは、複数のクライアントに対してプロトコルマッパーとロールスコープマッピングを設定します。

クライアントスコープは、OAuth 2.0のスコープパラメータもサポートしています。クライアントアプリケーションは、このパラメータを使用して、アプリケーションの要件に応じて、アクセストークンに要求するクレームまたはロールを指定します。

クライアントスコープを作成するには、次の手順に従ってください。

1. メニューから**クライアントスコープ**をクリックします。
2. **作成**をクリックします。
3. クライアントスコープに名前を付けます。
4. **保存**をクリックします。

クライアントスコープには、通常のクライアントと同じタブがあり、プロトコルマッパーとロールスコープマッピングを定義できます。これらのマッピングは、他のクライアントから継承することができ、このクライアントスコープから継承するように設定されます。

#### プロトコル

クライアントスコープを作成する際は、**プロトコル**を選択します。同じスコープにリンクされたクライアントは、すべて同じプロトコルを使用する必要があります。

各レルムには、メニューに事前定義された組み込みのクライアントスコープがいくつかあります。

- **SAMLプロトコル**: `role_list` スコープ。このスコープには、SAMLアサーション内のロールリスト用のプロトコルマッパーが1つ含まれています。
- **OpenID Connectプロトコル**: いくつかのクライアントスコープが利用可能です。
- `roles`: このスコープはOpenID Connect仕様では定義されておらず、アクセストークンのスコープクレームに自動的に追加されません。このスコープにはマッパーが含まれており、ユーザーのロールをアクセストークンに追加したり、少なくとも1つのクライアントロールを持つクライアントにオーディエンスを追加したりするために使用されます。これらのマッパーについては、**オーディエンス**セクションで詳しく説明します。
- `web-origins`: このスコープもOpenID Connect仕様では定義されておらず、アクセストークンのスコープクレームに追加されません。このスコープは、アクセストークンの`allowed-origins`クレームに許可されたWebオリジンを追加するために使用されます。
- `microprofile-jwt`: このスコープは、MicroProfile/JWT Auth Specificationで定義されたクレームを処理します。このスコープは、`upn`クレーム用のユーザープロパティマッパーと、`groups`クレーム用のレルムロールマッパーを定義しています。これらのマッパーは変更可能であり、MicroProfile/JWT固有のクレームを作成するために異なるプロパティを使用することができます。
- `offline_access`: このスコープは、クライアントがオフライントークンを取得する必要がある場合に使用されます。オフライントークンについては、**オフラインアクセス**セクションとOpenID Connect仕様を参照してください。
- `profile`, `email`, `address`, `phone`: これらのクライアントスコープは、OpenID Connect仕様で定義されています。これらのスコープには、定義されたロールスコープマッピングはありませんが、プロトコルマッパーは定義されています。これらのマッパーは、OpenID Connect仕様で定義されたクレームに対応しています。
- 例として、`phone`クライアントスコープを開いて**マッパー**タブを開くと、`phone`スコープの仕様で定義されたクレームに対応するプロトコルマッパーが表示されます。

**クライアントスコープマッパー**

`phone`クライアントスコープがクライアントにリンクされると、クライアントは自動的に`phone`クライアントスコープに定義されたすべてのプロトコルマッパーを継承します。このクライアントに対して発行されたアクセストークンには、ユーザーが電話番号を定義している場合、ユーザーの電話番号情報が含まれます。

組み込みのクライアントスコープには、仕様に定義されているプロトコルマッパーが含まれています。クライアントスコープを編集したり、プロトコルマッパーやロールスコープマッピングを作成、更新、削除したりすることができます。

#### 承認関連の設定

クライアントスコープには、承認画面に関するオプションが含まれています。これらのオプションは、リンクされたクライアントが**承認が必要**の場合に役立ちます。

- **承認画面に表示**
- このオプションが有効になっており、スコープが承認を必要とするクライアントに追加された場合、**承認画面のテキスト**に指定されたテキストが承認画面に表示されます。このテキストは、ユーザーが認証され、Keycloakからクライアントにリダイレクトされる前に表示されます。
- このオプションが無効になっている場合、このクライアントスコープは承認画面に表示されません。
- **承認画面のテキスト**
- 承認が必要な場合、このクライアントスコープがクライアントに追加されると、承認画面に表示されるテキストはデフォルトでクライアントスコープの名前になります。このテキストの値は、`${var-name}`文字列を含む置換変数を指定することでカスタマイズできます。カスタマイズされた値は、テーマのプロパティファイル内で設定されます。カスタマイズの詳細については、**サーバー開発者ガイド**を参照してください。

#### クライアントスコープをクライアントにリンクする

クライアントスコープとクライアントのリンクは、クライアントの**クライアントスコープ**タブで設定されます。クライアントスコープとクライアントをリンクする方法は2つあります。

- **デフォルトクライアントスコープ**: この設定は、OpenID ConnectクライアントとSAMLクライアントに適用されます。デフォルトクライアントスコープは、クライアントに対してOpenID ConnectトークンまたはSAMLアサーションを発行する際に適用されます。クライアントは、クライアントスコープに定義されているプロトコルマッパーとロールスコープマッピングを継承します。OpenID Connectプロトコルでは、マッパーとロールスコープマッピングは、OpenID Connect認証要求でスコープパラメータに使用される値に関係なく、常に適用されます。
- **オプションクライアントスコープ**: この設定は、OpenID Connectクライアントのみに適用されます。オプションクライアントスコープは、クライアントに対してトークンを発行する際に適用されますが、OpenID Connect認証要求のスコープパラメータによって要求された場合のみ適用されます。

**例**

この例では、クライアントは`profile`と`email`をデフォルトクライアントスコープとしてリンクし、`phone`と`address`をオプションクライアントスコープとしてリンクしています。クライアントは、OpenID Connect認証エンドポイントに要求を送信する際に、スコープパラメータの値を使用します。

```
scope=openid phone
```

スコープパラメータには、スペースで区切られたスコープ値を含む文字列が含まれています。`openid`値は、すべてのOpenID Connect要求で使用されるメタ値です。トークンには、デフォルトクライアントスコープの`profile`と`email`、およびスコープパラメータによって要求されたオプションクライアントスコープの`phone`のマッパーとロールスコープマッピングが含まれます。

#### クライアントスコープを評価する

**マッパー**タブには、このクライアントに宣言されたプロトコルマッパーが含まれ、**スコープ**タブにはロールスコープマッピングが含まれます。これらには、クライアントスコープから継承されたマッパーやスコープマッピングは含まれていません。クライアントに対してトークンを生成する際に使用される、有効なプロトコルマッパー（つまり、クライアント自身で定義されたプロトコルマッパーと、リンクされたクライアントスコープから継承されたプロトコルマッパー）と、有効なロールスコープマッピングを確認できます。

**手順**

1. クライアントの**クライアントスコープ**タブをクリックします。
2. サブタブの**評価**を開きます。
3. 適用するオプションクライアントスコープを選択します。
4. これにより、スコープパラメータの値も表示されます。このパラメータは、アプリケーションからKeycloak OpenID Connect認証エンドポイントに送信する必要があります。

アプリケーションからスコープパラメータのカスタム値を送信するには、JavaScriptアダプターセクションを参照してください。

すべての例は、特定のユーザーに対して生成され、特定のクライアントに対して発行され、スコープパラメータの指定された値を使用します。例には、使用されるすべてのクレームとロールマッピングが含まれます。

#### クライアントスコープの権限

ユーザーにトークンを発行する際に、クライアントスコープは、ユーザーがその使用を許可されている場合にのみ適用されます。

クライアントスコープにロールスコープマッピングが定義されていない場合、すべてのユーザーがそのクライアントスコープを使用することができます。ただし、クライアントスコープにロールスコープマッピングが定義されている場合、ユーザーは少なくとも1つのロールのメンバーである必要があります。ユーザーのロールとクライアントスコープのロールの間に共通点がある必要があります。複合ロールは、この共通点を評価する際に考慮されます。

ユーザーがクライアントスコープを使用する権限がない場合、トークンを生成する際に、プロトコルマッパーやロールスコープマッピングは使用されません。クライアントスコープは、トークンのスコープ値に表示されません。

#### レルムのデフォルトクライアントスコープ

**レルムのデフォルトクライアントスコープ**を使用して、新しく作成されたクライアントに自動的にリンクされるクライアントスコープのセットを定義します。

**手順**

1. クライアントの**クライアントスコープ**タブをクリックします。
2. ここで、新しく作成されたクライアントのデフォルトクライアントスコープとオプションクライアントスコープに追加するクライアントスコープを選択します。

クライアントが作成されると、必要に応じてデフォルトクライアントスコープのリンクを解除できます。これは、デフォルトロールを削除するのと同様です。

#### スコープの説明

- **クライアントスコープ**: クライアントスコープは、Keycloak内のエンティティであり、レルムレベルで設定され、クライアントにリンクできます。クライアントスコープは、Keycloak認証エンドポイントに要求を送信する際に、スコープパラメータの対応する値と共に名前で参照されます。詳細については、**クライアントスコープのリンク**セクションを参照してください。
- **ロールスコープマッピング**: これは、クライアントまたはクライアントスコープの**スコープ**タブにあります。**ロールスコープマッピング**を使用して、アクセストークンで使用できるロールを制限します。詳細については、**ロールスコープマッピング**セクションを参照してください。
- **承認スコープ**: **承認スコープ**は、アプリケーションで実行できるアクションを網羅しています。詳細については、**承認サービスガイド**を参照してください。

### クライアントポリシー

クライアントポリシーは、クライアントアプリケーションのセキュリティを強化するために、次の３つの重要な役割を果たします。

* **クライアント構成の制限:** クライアントが持つことができる構成オプションを制限し、不適切な設定を防ぎます。
* **クライアント構成の検証:** クライアント構成がセキュリティ標準やプロファイルに準拠していることを検証します。
* **セキュリティプロファイルへの準拠:** FAPI (Financial-grade API) や OAuth 2.1 などのセキュリティプロファイルへの準拠を容易にします。

#### ユースケース

クライアントポリシーは、様々なユースケースに対応できます。

* **クライアント作成/更新時の設定の強制:** クライアントの作成や更新時に、クライアントポリシーによって設定が強制されます。これは、クライアント登録ポリシーと類似していますが、クライアントポリシーは、クライアント登録ポリシーよりも幅広い設定をカバーできます。
* **クライアント構成の自動検証:** クライアントが Proof Key for Code Exchange (PKCE)、Request Object Signing Algorithm などの設定に従っているかどうかを検証し、セキュリティ要件を満たすように自動的に構成できます。
* **セキュリティプロファイルへの準拠:** FAPI や OAuth 2.1 などのセキュリティプロファイルに準拠するクライアントを簡単に作成できます。

#### クライアントポリシーのアーキテクチャ

クライアントポリシーは、条件、実行者、プロファイル、ポリシーという4つの要素から構成されています。

* **条件:** ポリシーが適用されるクライアントと、適用されるタイミングを決定します。
* **実行者:** ポリシーが適用されたクライアントに対して実行されるアクションを指定します。
* **プロファイル:** FAPI や OAuth 2.1 などのセキュリティプロファイルを定義します。
* **ポリシー:** 複数の条件とプロファイルを組み合わせ、クライアントへの適用ルールを定義します。

#### 構成

クライアントポリシーは、Keycloak の管理コンソールから設定できます。

* **グローバルクライアントプロファイル:** FAPI 1 Baseline、FAPI 1 Advanced、FAPI CIBA、FAPI 2、OAuth 2.1 などのセキュリティプロファイルが事前に設定されています。
* **クライアントポリシー:** 各レルムに個別設定できるポリシーです。

#### 後方互換性

クライアントポリシーは、クライアント登録ポリシーを置き換えることを目的としています。しかし、クライアント登録ポリシーは、現時点では引き続き使用できます。将来的には、クライアント登録ポリシーはクライアントポリシーに自動的に移行される予定です。

#### クライアントシークレットローテーションの例

クライアントシークレットローテーションは、クライアントシークレットのセキュリティを強化する重要な手段です。クライアントポリシーを使用して、クライアントシークレットローテーションを自動化することができます。
